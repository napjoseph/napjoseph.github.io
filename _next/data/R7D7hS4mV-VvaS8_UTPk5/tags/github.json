{"pageProps":{"tag":{"name":"GitHub","slug":"github"},"articles":[{"title":"Manually Create Coverage Badges Using GitHub Actions","layout":"posts","slug":"manually-create-coverage-badges-using-github-actions","draft":false,"frontMatter":{"title":"Manually Create Coverage Badges Using GitHub Actions","publishedDate":"2023-04-09T23:31:00Z","tags":["GitHub","GitHub Actions","Coverage"],"description":"","disableComments":false},"rawContent":"\nAdding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\n\n## Prerequisites\n\n- A [Node.js](https://nodejs.org/) project with test coverage reports generated by a tool like [c8](https://github.com/bcoe/c8) or [Istanbul](https://github.com/istanbuljs/nyc).\n- A GitHub repository for your project.\n- [GitHub deploy keys](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) configured for your repository.\n\nLet's get started!\n\n## Step 1: Install Cheerio\n\nBefore anything else, make sure you have a coverage report generated by your testing tool. In our case, we will use the HTML report generated by [c8](https://github.com/bcoe/c8). This report will look something like this:\n\n```html filename=./coverage/index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <div class=\"wrapper\">\n      <div class=\"pad1\">\n        <div class=\"clearfix\">\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Statements</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Branches</span>\n            <span class=\"fraction\">74/74</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">90.9%</span>\n            <span class=\"quiet\">Functions</span>\n            <span class=\"fraction\">33/33</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Lines</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\nWe will use [cheerio](https://github.com/cheeriojs/cheerio), a [jQuery](https://jquery.com/)-like library for server-side to extract the percentage data from the HTML. Install it to your `devDependencies` using the package manager of your choice:\n\n```bash\n# npm\nnpm install --save-dev cheerio\n\n# yarn\nyarn add --dev cheerio\n\n# pnpm\npnpm add --save-dev cheerio\n```\n\n## Step 2: Create a Script to Extract Coverage Data\n\nNext, we need to create the actual script that will extract the coverage data from the HTML report. Create a new file called `./scripts/generate-badges.js` and add the following code:\n\n```js filename=./scripts/generate-badges.js\nconst fs = require('fs');\nconst https = require('https');\nconst cheerio = require('cheerio');\n\nconst coverageFile = './coverage/index.html';\nconst badgesDir = './coverage/badges';\n\n// Read the coverage HTML file.\nfs.readFile(coverageFile, 'utf-8', (err, data) => {\n  if (err) {\n    console.error(`Error reading coverage file: ${err}`);\n    process.exit(1);\n  }\n\n  // Parse the HTML using Cheerio.\n  const $ = cheerio.load(data);\n\n  // Construct the shields.io URL for each badge.\n  const statementsBadgeUrl = generateUrl('statements', extractPercentage($, 1));\n  const branchesBadgeUrl = generateUrl('branches', extractPercentage($, 2));\n  const functionsBadgeUrl = generateUrl('functions', extractPercentage($, 3));\n  const linesBadgeUrl = generateUrl('lines', extractPercentage($, 4));\n\n  // Create the badges directory if it does not exist.\n  if (!fs.existsSync(badgesDir)) {\n    fs.mkdirSync(badgesDir);\n  }\n\n  // Download each badge and save it to the badges directory.\n  downloadBadge(statementsBadgeUrl, `${badgesDir}/statements.svg`);\n  downloadBadge(branchesBadgeUrl, `${badgesDir}/branches.svg`);\n  downloadBadge(functionsBadgeUrl, `${badgesDir}/functions.svg`);\n  downloadBadge(linesBadgeUrl, `${badgesDir}/lines.svg`);\n\n  console.log('Code coverage badges created successfully.');\n});\n\n/**\n * Generate a shields.io URL for a badge.\n *\n * Change the color of the badge based on the percentage.\n *\n * @param {string} text The text to display on the badge.\n * @param {number} percentage The percentage to display on the badge.\n * @returns {string} The shields.io URL.\n */\nconst generateUrl = (text, percentage) => {\n  let color = 'brightgreen';\n  if (percentage < 70) {\n    color = 'red';\n  } else if (percentage < 80) {\n    color = 'yellow';\n  } else if (percentage < 90) {\n    color = 'orange';\n  }\n  return `https://img.shields.io/badge/coverage%3A${text}-${percentage}%25-${color}.svg`;\n};\n\n/**\n * Extract the code coverage percentage from the HTML.\n * @param {Cheerio} $ The Cheerio object.\n * @param {number} index The index of the element to extract.\n */\nconst extractPercentage = ($, index) => {\n  const text = $(`.pad1y:nth-child(${index}) span.strong`) ?? '0';\n  const percentage = text.text().trim().replace('%', '');\n  return parseFloat(percentage);\n};\n\n/**\n * Download a badge from shields.io.\n * @param {string} url The shields.io URL.\n * @param {string} filename The filename to save the badge to.\n */\nconst downloadBadge = (url, filename) => {\n  https.get(url, (res) => {\n    if (res.statusCode !== 200) {\n      console.error(`Error downloading badge: ${res.statusMessage}`);\n      return;\n    }\n\n    const file = fs.createWriteStream(filename);\n    res.pipe(file);\n    file.on('finish', () => {\n      file.close();\n    });\n  });\n};\n```\n\nThis is a fairly straightforward script that uses Cheerio to parse the HTML report and extract the coverage data. It then uses the data to generate the [shields.io](https://shields.io/) URLs for each badge type. Finally, it downloads each badge and saves it to the `./coverage/badges` directory.\n\nUpdate your `package.json` to add a new script that will run the `generate-badges.js` script:\n\n```json filename=package.json\n{\n  \"scripts\": {\n    // ...\n    \"generate-badges\": \"node ./scripts/generate-badges.js\"\n  }\n}\n```\n\nRun the script to generate the badges:\n\n```bash\n# generate the coverage report first\npnpm coverage\n\n# generate the badges\npnpm generate-badges\n```\n\n## Step 3: Configure GitHub Actions\n\n> **NOTE**: For this guide, we will use [pnpm](https://pnpm.io/), but the commands should be similar for other package managers.\n\n> **NOTE**: This requires that you have an SSH Deploy Key configured for your repository. See [Create SSH Deploy Key](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) for more information.\n\nIn your repository, create a `.github/workflows` directory if it doesn't already exist. Then, create a new YAML file inside the workflows directory called `coverage-badge.yml`. This file will define the GitHub Actions workflow that generates the coverage badge.\n\nAdd the following content to `coverage-badge.yml`:\n\n```yaml filename=.github/workflows/coverage-badge.yml\nname: (main) coverage badge\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage-badge:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: setup node\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node }}\n      - name: install pnpm\n        uses: pnpm/action-setup@v2\n        id: pnpm-install\n        with:\n          version: ${{ matrix.pnpm }}\n          run_install: false\n      - name: get pnpm store directory\n        id: pnpm-cache\n        shell: bash\n        run: |\n          echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n      - name: Setup pnpm cache\n        uses: actions/cache@v3\n        with:\n          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}\n          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-pnpm-store-\n      - name: install dependencies\n        run: pnpm install\n      - name: run coverage\n        run: pnpm coverage\n      - name: generate badges\n        run: pnpm generate-badges\n      - name: push coverage artifacts to another branch\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.COVERAGE_DEPLOY_KEY }}\n          publish_dir: ./coverage\n          publish_branch: coverage\n          allow_empty_commit: true\n```\n\nLet's break down the workflow into its various sections:\n\n```yaml\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n```\n\nThe workflow is triggered when there's a push to the `main` branch or can be triggered manually ([`workflow_dispatch`](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch)).\n\n```yaml\njobs:\n  covera:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: ${{ matrix.os }}\n```\n\nWe're using a matrix strategy to run the workflow on multiple operating systems, Node.js versions, and pnpm versions. For our purpose, we will only use one version of each, but this is a good practice to follow.\n\n```yaml\n- name: checkout repository\n  uses: actions/checkout@v3\n- name: setup node\n  uses: actions/setup-node@v3\n  with:\n    node-version: ${{ matrix.node }}\n```\n\nThis step checks out your repository using the [actions/checkout](https://github.com/actions/checkout) action. Then, it sets up Node.js using the [actions/setup-node](https://github.com/actions/setup-node) action.\n\n```yaml\n- name: install pnpm\n  uses: pnpm/action-setup@v2\n  id: pnpm-install\n  with:\n    version: ${{ matrix.pnpm }}\n    run_install: false\n```\n\nThis step installs pnpm using the [pnpm/action-setup](https://github.com/pnpm/action-setup) action and the specified pnpm version from the matrix. We're not installing any dependencies yet, so we don't need to run `pnpm install`.\n\n```yaml\n- name: get pnpm store directory\n  id: pnpm-cache\n  shell: bash\n  run: |\n    echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n- name: Setup pnpm cache\n  uses: actions/cache@v3\n  with:\n    path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}\n    key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}\n    restore-keys: |\n      ${{ runner.os }}-pnpm-store-\n- name: install dependencies\n  run: pnpm install\n```\n\nThese steps will use the cache from [actions/cache](https://github.com/actions/cache) and install the project's dependencies using pnpm. We're using the cache to reduce installation time and to avoid downloading the same dependencies multiple times.\n\n```yaml\n- name: run coverage\n  run: pnpm coverage\n- name: generate badges\n  run: pnpm generate-badges\n```\n\nThis step runs the `coverage` script, which should generate a coverage report. Then, it runs the `generate-badges` script, which should generate the coverage badges.\n\n```yaml\n- name: push coverage artifacts to another branch\n  uses: peaceiris/actions-gh-pages@v3\n  with:\n    deploy_key: ${{ secrets.COVERAGE_DEPLOY_KEY }}\n    publish_dir: ./coverage\n    publish_branch: coverage\n    allow_empty_commit: true\n```\n\nLastly, this step pushes the coverage artifacts, including the generated badges and the coverage report, to a separate coverage branch in your repository using the [peaceiris/actions-gh-pages](https://github.com/peaceiris/actions-gh-pages) action.\n\nOptions:\n\n- The `deploy_key` option is set to the `COVERAGE_DEPLOY_KEY` secret, which is a Deploy Key stored in your repository settings. This deploy key should have write access to the repository. Follow the instructions from [Create SSH Deploy Key](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) to generate it and add it to your repository.\n- The `publish_dir` is set to `./coverage`, which is the directory containing the coverage report and badges.\n- The `allow_empty_commit` option is set to true to allow empty commits if there are no changes in the coverage artifacts.\n- The `publish_branch` is the name of the branch you want to push the coverage artifacts to. It's currently set to `coverage`, but you can change it to whatever you want.\n\n## Step 4: Add Badge to README\n\nTo display the coverage badge in your README file, add the following line at the top of your `README.md` file:\n\n```md filename=README.md\n![Coverage: Statements](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/statements.svg)\n![Coverage: Branches](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/branches.svg)\n![Coverage: Functions](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/functions.svg)\n![Coverage: Lines](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/lines.svg)\n```\n\nThese lines will render the badges as an image. It should point to the latest badges in your `<PUBLISH_BRANCH_NAME>` branch.\n\n## Conclusion\n\nCongratulations! You have successfully created a dynamic coverage badge for your Node.js project. This badge will help you showcase your project's test coverage and encourage you to maintain a high level of code quality. Don't hesitate to customize this workflow to suit your needs and adapt it to different coverage tools and badge styles.\n\nHappy coding!\n","excerpt":"\nAdding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\n\n##...","serializedContent":{"compiledSource":"var d=Object.defineProperty,h=Object.defineProperties;var g=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var p=(a,t,n)=>t in a?d(a,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):a[t]=n,e=(a,t)=>{for(var n in t||(t={}))o.call(t,n)&&p(a,n,t[n]);if(s)for(var n of s(t))i.call(t,n)&&p(a,n,t[n]);return a},c=(a,t)=>h(a,g(t));var l=(a,t)=>{var n={};for(var r in a)o.call(a,r)&&t.indexOf(r)<0&&(n[r]=a[r]);if(a!=null&&s)for(var r of s(a))t.indexOf(r)<0&&i.call(a,r)&&(n[r]=a[r]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var r=n,{components:a}=r,t=l(r,[\"components\"]);return mdx(MDXLayout,c(e(e({},layoutProps),t),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Adding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\"),mdx(\"h2\",e({},{id:\"prerequisites\"}),\"Prerequisites\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"A \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://nodejs.org/\"}),\"Node.js\"),\" project with test coverage reports generated by a tool like \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/bcoe/c8\"}),\"c8\"),\" or \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/istanbuljs/nyc\"}),\"Istanbul\"),\".\"),mdx(\"li\",{parentName:\"ul\"},\"A GitHub repository for your project.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"GitHub deploy keys\"),\" configured for your repository.\")),mdx(\"p\",null,\"Let's get started!\"),mdx(\"h2\",e({},{id:\"step-1-install-cheerio\"}),\"Step 1: Install Cheerio\"),mdx(\"p\",null,\"Before anything else, make sure you have a coverage report generated by your testing tool. In our case, we will use the HTML report generated by \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/bcoe/c8\"}),\"c8\"),\". This report will look something like this:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-html\",metastring:\"filename=./coverage/index.html\",filename:\"./coverage/index.html\"}),`<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <div class=\"wrapper\">\n      <div class=\"pad1\">\n        <div class=\"clearfix\">\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Statements</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Branches</span>\n            <span class=\"fraction\">74/74</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">90.9%</span>\n            <span class=\"quiet\">Functions</span>\n            <span class=\"fraction\">33/33</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Lines</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n`)),mdx(\"p\",null,\"We will use \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/cheeriojs/cheerio\"}),\"cheerio\"),\", a \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://jquery.com/\"}),\"jQuery\"),\"-like library for server-side to extract the percentage data from the HTML. Install it to your \",mdx(\"inlineCode\",{parentName:\"p\"},\"devDependencies\"),\" using the package manager of your choice:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-bash\"}),`# npm\nnpm install --save-dev cheerio\n\n# yarn\nyarn add --dev cheerio\n\n# pnpm\npnpm add --save-dev cheerio\n`)),mdx(\"h2\",e({},{id:\"step-2-create-a-script-to-extract-coverage-data\"}),\"Step 2: Create a Script to Extract Coverage Data\"),mdx(\"p\",null,\"Next, we need to create the actual script that will extract the coverage data from the HTML report. Create a new file called \",mdx(\"inlineCode\",{parentName:\"p\"},\"./scripts/generate-badges.js\"),\" and add the following code:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\",metastring:\"filename=./scripts/generate-badges.js\",filename:\"./scripts/generate-badges.js\"}),`const fs = require('fs');\nconst https = require('https');\nconst cheerio = require('cheerio');\n\nconst coverageFile = './coverage/index.html';\nconst badgesDir = './coverage/badges';\n\n// Read the coverage HTML file.\nfs.readFile(coverageFile, 'utf-8', (err, data) => {\n  if (err) {\n    console.error(\\`Error reading coverage file: \\${err}\\`);\n    process.exit(1);\n  }\n\n  // Parse the HTML using Cheerio.\n  const $ = cheerio.load(data);\n\n  // Construct the shields.io URL for each badge.\n  const statementsBadgeUrl = generateUrl('statements', extractPercentage($, 1));\n  const branchesBadgeUrl = generateUrl('branches', extractPercentage($, 2));\n  const functionsBadgeUrl = generateUrl('functions', extractPercentage($, 3));\n  const linesBadgeUrl = generateUrl('lines', extractPercentage($, 4));\n\n  // Create the badges directory if it does not exist.\n  if (!fs.existsSync(badgesDir)) {\n    fs.mkdirSync(badgesDir);\n  }\n\n  // Download each badge and save it to the badges directory.\n  downloadBadge(statementsBadgeUrl, \\`\\${badgesDir}/statements.svg\\`);\n  downloadBadge(branchesBadgeUrl, \\`\\${badgesDir}/branches.svg\\`);\n  downloadBadge(functionsBadgeUrl, \\`\\${badgesDir}/functions.svg\\`);\n  downloadBadge(linesBadgeUrl, \\`\\${badgesDir}/lines.svg\\`);\n\n  console.log('Code coverage badges created successfully.');\n});\n\n/**\n * Generate a shields.io URL for a badge.\n *\n * Change the color of the badge based on the percentage.\n *\n * @param {string} text The text to display on the badge.\n * @param {number} percentage The percentage to display on the badge.\n * @returns {string} The shields.io URL.\n */\nconst generateUrl = (text, percentage) => {\n  let color = 'brightgreen';\n  if (percentage < 70) {\n    color = 'red';\n  } else if (percentage < 80) {\n    color = 'yellow';\n  } else if (percentage < 90) {\n    color = 'orange';\n  }\n  return \\`https://img.shields.io/badge/coverage%3A\\${text}-\\${percentage}%25-\\${color}.svg\\`;\n};\n\n/**\n * Extract the code coverage percentage from the HTML.\n * @param {Cheerio} $ The Cheerio object.\n * @param {number} index The index of the element to extract.\n */\nconst extractPercentage = ($, index) => {\n  const text = $(\\`.pad1y:nth-child(\\${index}) span.strong\\`) ?? '0';\n  const percentage = text.text().trim().replace('%', '');\n  return parseFloat(percentage);\n};\n\n/**\n * Download a badge from shields.io.\n * @param {string} url The shields.io URL.\n * @param {string} filename The filename to save the badge to.\n */\nconst downloadBadge = (url, filename) => {\n  https.get(url, (res) => {\n    if (res.statusCode !== 200) {\n      console.error(\\`Error downloading badge: \\${res.statusMessage}\\`);\n      return;\n    }\n\n    const file = fs.createWriteStream(filename);\n    res.pipe(file);\n    file.on('finish', () => {\n      file.close();\n    });\n  });\n};\n`)),mdx(\"p\",null,\"This is a fairly straightforward script that uses Cheerio to parse the HTML report and extract the coverage data. It then uses the data to generate the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://shields.io/\"}),\"shields.io\"),\" URLs for each badge type. Finally, it downloads each badge and saves it to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"./coverage/badges\"),\" directory.\"),mdx(\"p\",null,\"Update your \",mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\"),\" to add a new script that will run the \",mdx(\"inlineCode\",{parentName:\"p\"},\"generate-badges.js\"),\" script:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\",metastring:\"filename=package.json\",filename:\"package.json\"}),`{\n  \"scripts\": {\n    // ...\n    \"generate-badges\": \"node ./scripts/generate-badges.js\"\n  }\n}\n`)),mdx(\"p\",null,\"Run the script to generate the badges:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-bash\"}),`# generate the coverage report first\npnpm coverage\n\n# generate the badges\npnpm generate-badges\n`)),mdx(\"h2\",e({},{id:\"step-3-configure-github-actions\"}),\"Step 3: Configure GitHub Actions\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": For this guide, we will use \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://pnpm.io/\"}),\"pnpm\"),\", but the commands should be similar for other package managers.\")),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": This requires that you have an SSH Deploy Key configured for your repository. See \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"Create SSH Deploy Key\"),\" for more information.\")),mdx(\"p\",null,\"In your repository, create a \",mdx(\"inlineCode\",{parentName:\"p\"},\".github/workflows\"),\" directory if it doesn't already exist. Then, create a new YAML file inside the workflows directory called \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage-badge.yml\"),\". This file will define the GitHub Actions workflow that generates the coverage badge.\"),mdx(\"p\",null,\"Add the following content to \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage-badge.yml\"),\":\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\",metastring:\"filename=.github/workflows/coverage-badge.yml\",filename:\".github/workflows/coverage-badge.yml\"}),`name: (main) coverage badge\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage-badge:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: \\${{ matrix.os }}\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: setup node\n        uses: actions/setup-node@v3\n        with:\n          node-version: \\${{ matrix.node }}\n      - name: install pnpm\n        uses: pnpm/action-setup@v2\n        id: pnpm-install\n        with:\n          version: \\${{ matrix.pnpm }}\n          run_install: false\n      - name: get pnpm store directory\n        id: pnpm-cache\n        shell: bash\n        run: |\n          echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n      - name: Setup pnpm cache\n        uses: actions/cache@v3\n        with:\n          path: \\${{ steps.pnpm-cache.outputs.STORE_PATH }}\n          key: \\${{ runner.os }}-pnpm-store-\\${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            \\${{ runner.os }}-pnpm-store-\n      - name: install dependencies\n        run: pnpm install\n      - name: run coverage\n        run: pnpm coverage\n      - name: generate badges\n        run: pnpm generate-badges\n      - name: push coverage artifacts to another branch\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: \\${{ secrets.COVERAGE_DEPLOY_KEY }}\n          publish_dir: ./coverage\n          publish_branch: coverage\n          allow_empty_commit: true\n`)),mdx(\"p\",null,\"Let's break down the workflow into its various sections:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`on:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n`)),mdx(\"p\",null,\"The workflow is triggered when there's a push to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"main\"),\" branch or can be triggered manually (\",mdx(\"a\",e({parentName:\"p\"},{href:\"https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch\"}),mdx(\"inlineCode\",{parentName:\"a\"},\"workflow_dispatch\")),\").\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`jobs:\n  covera:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: \\${{ matrix.os }}\n`)),mdx(\"p\",null,\"We're using a matrix strategy to run the workflow on multiple operating systems, Node.js versions, and pnpm versions. For our purpose, we will only use one version of each, but this is a good practice to follow.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: checkout repository\n  uses: actions/checkout@v3\n- name: setup node\n  uses: actions/setup-node@v3\n  with:\n    node-version: \\${{ matrix.node }}\n`)),mdx(\"p\",null,\"This step checks out your repository using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/checkout\"}),\"actions/checkout\"),\" action. Then, it sets up Node.js using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/setup-node\"}),\"actions/setup-node\"),\" action.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: install pnpm\n  uses: pnpm/action-setup@v2\n  id: pnpm-install\n  with:\n    version: \\${{ matrix.pnpm }}\n    run_install: false\n`)),mdx(\"p\",null,\"This step installs pnpm using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/pnpm/action-setup\"}),\"pnpm/action-setup\"),\" action and the specified pnpm version from the matrix. We're not installing any dependencies yet, so we don't need to run \",mdx(\"inlineCode\",{parentName:\"p\"},\"pnpm install\"),\".\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: get pnpm store directory\n  id: pnpm-cache\n  shell: bash\n  run: |\n    echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n- name: Setup pnpm cache\n  uses: actions/cache@v3\n  with:\n    path: \\${{ steps.pnpm-cache.outputs.STORE_PATH }}\n    key: \\${{ runner.os }}-pnpm-store-\\${{ hashFiles('**/pnpm-lock.yaml') }}\n    restore-keys: |\n      \\${{ runner.os }}-pnpm-store-\n- name: install dependencies\n  run: pnpm install\n`)),mdx(\"p\",null,\"These steps will use the cache from \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/cache\"}),\"actions/cache\"),\" and install the project's dependencies using pnpm. We're using the cache to reduce installation time and to avoid downloading the same dependencies multiple times.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: run coverage\n  run: pnpm coverage\n- name: generate badges\n  run: pnpm generate-badges\n`)),mdx(\"p\",null,\"This step runs the \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage\"),\" script, which should generate a coverage report. Then, it runs the \",mdx(\"inlineCode\",{parentName:\"p\"},\"generate-badges\"),\" script, which should generate the coverage badges.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: push coverage artifacts to another branch\n  uses: peaceiris/actions-gh-pages@v3\n  with:\n    deploy_key: \\${{ secrets.COVERAGE_DEPLOY_KEY }}\n    publish_dir: ./coverage\n    publish_branch: coverage\n    allow_empty_commit: true\n`)),mdx(\"p\",null,\"Lastly, this step pushes the coverage artifacts, including the generated badges and the coverage report, to a separate coverage branch in your repository using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/peaceiris/actions-gh-pages\"}),\"peaceiris/actions-gh-pages\"),\" action.\"),mdx(\"p\",null,\"Options:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"deploy_key\"),\" option is set to the \",mdx(\"inlineCode\",{parentName:\"li\"},\"COVERAGE_DEPLOY_KEY\"),\" secret, which is a Deploy Key stored in your repository settings. This deploy key should have write access to the repository. Follow the instructions from \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"Create SSH Deploy Key\"),\" to generate it and add it to your repository.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"publish_dir\"),\" is set to \",mdx(\"inlineCode\",{parentName:\"li\"},\"./coverage\"),\", which is the directory containing the coverage report and badges.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"allow_empty_commit\"),\" option is set to true to allow empty commits if there are no changes in the coverage artifacts.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"publish_branch\"),\" is the name of the branch you want to push the coverage artifacts to. It's currently set to \",mdx(\"inlineCode\",{parentName:\"li\"},\"coverage\"),\", but you can change it to whatever you want.\")),mdx(\"h2\",e({},{id:\"step-4-add-badge-to-readme\"}),\"Step 4: Add Badge to README\"),mdx(\"p\",null,\"To display the coverage badge in your README file, add the following line at the top of your \",mdx(\"inlineCode\",{parentName:\"p\"},\"README.md\"),\" file:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-md\",metastring:\"filename=README.md\",filename:\"README.md\"}),`![Coverage: Statements](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/statements.svg)\n![Coverage: Branches](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/branches.svg)\n![Coverage: Functions](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/functions.svg)\n![Coverage: Lines](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/lines.svg)\n`)),mdx(\"p\",null,\"These lines will render the badges as an image. It should point to the latest badges in your \",mdx(\"inlineCode\",{parentName:\"p\"},\"<PUBLISH_BRANCH_NAME>\"),\" branch.\"),mdx(\"h2\",e({},{id:\"conclusion\"}),\"Conclusion\"),mdx(\"p\",null,\"Congratulations! You have successfully created a dynamic coverage badge for your Node.js project. This badge will help you showcase your project's test coverage and encourage you to maintain a high level of code quality. Don't hesitate to customize this workflow to suit your needs and adapt it to different coverage tools and badge styles.\"),mdx(\"p\",null,\"Happy coding!\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}},{"title":"Copy Issue Labels From Another GitHub Repository","layout":"posts","slug":"copy-issue-labels-from-another-github-repository","draft":false,"frontMatter":{"title":"Copy Issue Labels From Another GitHub Repository","publishedDate":"2023-03-29T18:31:00Z","tags":["GitHub"],"description":"","disableComments":false},"rawContent":"\nIf you manage multiple projects across different GitHub Organizations, you may have faced a common scenario: the need to copy [GitHub issue labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels) from one repository to another. It used to be a manual process before, but luckily we can now use [GitHub's official CLI](https://cli.github.com/).\n\n## Why copy issue labels?\n\nHere are some common scenarios when you might need to copy issue labels between projects:\n\n- **Standardization**: If your Organization requires a standard list of issue labels for all projects, copying issue labels from an existing project with the required labels ensures consistency.\n- **Project Migration**: When a project is moved from one Organization to another, you might want to retain the issue labels to maintain the same workflow and issue categorization.\n- **Team Collaboration**: If multiple teams within an Organization work on similar projects, having a unified set of issue labels for better collaboration and understanding across teams is helpful.\n\n## Using the GitHub CLI\n\nBefore we dive into the process, make sure you have the GitHub CLI installed on your system. If you haven't installed it yet, head to https://cli.github.com/ and follow the installation instructions for your operating system.\n\nYou can authenticate with the CLI using:\n\n```bash\ngh auth login\n```\n\nOnce you have the GitHub CLI installed and configured, you can copy issue labels between repositories by executing the following command:\n\n```bash\ngh label clone owner-name/source-repo-name --repo owner-name/destination-repo-name --force\n```\n\nHere's a breakdown of the command:\n\n- `gh`: The GitHub CLI command.\n- `label`: The command group for working with issue labels.\n- `clone`: The command to copy labels from one repository to another.\n- `owner-name/source-repo-name`: The source repository from which you want to copy the issue labels.\n- `--repo`: The flag to specify the destination repository to which the issue labels will be copied.\n- `owner-name/destination-repo-name`: The destination repository to which the issue labels will be copied.\n- `--force`: Optional flag to overwrite existing labels in the destination repository.\n\nDocumentation for the command can be found at https://cli.github.com/manual/gh_label_clone.\n\n> **NOTE**: Please note that you must have the necessary permissions (write access) for the destination repositories.\n\nOnce the command executes successfully, all issue labels from `owner-name/source-repo-name` will be copied to `owner-name/destination-repo-name`, ensuring that the latter now follows the Organization's standard list of issue labels.\n\n## Creating default labels for your Organization\n\nAs an Organization owner, you can also create default labels that will be automatically included in every new repository in your Organization. This is a convenient way to standardize issue labels across all projects within your Organization.\n\nPlease refer to the GitHub documentation on [Managing Default Labels for Repositories in Your Organization](https://docs.github.com/en/organizations/managing-organization-settings/managing-default-labels-for-repositories-in-your-organization) for detailed instructions and screenshots.\n\n> **NOTE**: Adding, editing, or deleting a default label does not affect existing repositories. Default labels only apply to new repositories created after the changes.\n","excerpt":"\nIf you manage multiple projects across different GitHub Organizations, you may have faced a common scenario: the need to copy [GitHub issue labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels) from one repository to another. It used to be a manual pro...","serializedContent":{"compiledSource":"var c=Object.defineProperty,m=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var l=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var r=(e,a,o)=>a in e?c(e,a,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[a]=o,n=(e,a)=>{for(var o in a||(a={}))l.call(a,o)&&r(e,o,a[o]);if(i)for(var o of i(a))s.call(a,o)&&r(e,o,a[o]);return e},p=(e,a)=>m(e,h(a));var u=(e,a)=>{var o={};for(var t in e)l.call(e,t)&&a.indexOf(t)<0&&(o[t]=e[t]);if(e!=null&&i)for(var t of i(e))a.indexOf(t)<0&&s.call(e,t)&&(o[t]=e[t]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var t=o,{components:e}=t,a=u(t,[\"components\"]);return mdx(MDXLayout,p(n(n({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"If you manage multiple projects across different GitHub Organizations, you may have faced a common scenario: the need to copy \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels\"}),\"GitHub issue labels\"),\" from one repository to another. It used to be a manual process before, but luckily we can now use \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://cli.github.com/\"}),\"GitHub's official CLI\"),\".\"),mdx(\"h2\",n({},{id:\"why-copy-issue-labels\"}),\"Why copy issue labels?\"),mdx(\"p\",null,\"Here are some common scenarios when you might need to copy issue labels between projects:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"strong\",{parentName:\"li\"},\"Standardization\"),\": If your Organization requires a standard list of issue labels for all projects, copying issue labels from an existing project with the required labels ensures consistency.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"strong\",{parentName:\"li\"},\"Project Migration\"),\": When a project is moved from one Organization to another, you might want to retain the issue labels to maintain the same workflow and issue categorization.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"strong\",{parentName:\"li\"},\"Team Collaboration\"),\": If multiple teams within an Organization work on similar projects, having a unified set of issue labels for better collaboration and understanding across teams is helpful.\")),mdx(\"h2\",n({},{id:\"using-the-github-cli\"}),\"Using the GitHub CLI\"),mdx(\"p\",null,\"Before we dive into the process, make sure you have the GitHub CLI installed on your system. If you haven't installed it yet, head to \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://cli.github.com/\"}),\"https://cli.github.com/\"),\" and follow the installation instructions for your operating system.\"),mdx(\"p\",null,\"You can authenticate with the CLI using:\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-bash\"}),`gh auth login\n`)),mdx(\"p\",null,\"Once you have the GitHub CLI installed and configured, you can copy issue labels between repositories by executing the following command:\"),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-bash\"}),`gh label clone owner-name/source-repo-name --repo owner-name/destination-repo-name --force\n`)),mdx(\"p\",null,\"Here's a breakdown of the command:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"gh\"),\": The GitHub CLI command.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"label\"),\": The command group for working with issue labels.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"clone\"),\": The command to copy labels from one repository to another.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"owner-name/source-repo-name\"),\": The source repository from which you want to copy the issue labels.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"--repo\"),\": The flag to specify the destination repository to which the issue labels will be copied.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"owner-name/destination-repo-name\"),\": The destination repository to which the issue labels will be copied.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"--force\"),\": Optional flag to overwrite existing labels in the destination repository.\")),mdx(\"p\",null,\"Documentation for the command can be found at \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://cli.github.com/manual/gh_label_clone\"}),\"https://cli.github.com/manual/gh_label_clone\"),\".\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": Please note that you must have the necessary permissions (write access) for the destination repositories.\")),mdx(\"p\",null,\"Once the command executes successfully, all issue labels from \",mdx(\"inlineCode\",{parentName:\"p\"},\"owner-name/source-repo-name\"),\" will be copied to \",mdx(\"inlineCode\",{parentName:\"p\"},\"owner-name/destination-repo-name\"),\", ensuring that the latter now follows the Organization's standard list of issue labels.\"),mdx(\"h2\",n({},{id:\"creating-default-labels-for-your-organization\"}),\"Creating default labels for your Organization\"),mdx(\"p\",null,\"As an Organization owner, you can also create default labels that will be automatically included in every new repository in your Organization. This is a convenient way to standardize issue labels across all projects within your Organization.\"),mdx(\"p\",null,\"Please refer to the GitHub documentation on \",mdx(\"a\",n({parentName:\"p\"},{href:\"https://docs.github.com/en/organizations/managing-organization-settings/managing-default-labels-for-repositories-in-your-organization\"}),\"Managing Default Labels for Repositories in Your Organization\"),\" for detailed instructions and screenshots.\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": Adding, editing, or deleting a default label does not affect existing repositories. Default labels only apply to new repositories created after the changes.\")))}MDXContent.isMDXComponent=!0;\n","scope":{}}},{"title":"Deploying a Repository Inside a GitHub Organization to Vercel Using GitHub Actions","layout":"posts","slug":"deploying-a-repository-inside-a-github-organization-to-vercel-using-github-actions","draft":false,"frontMatter":{"title":"Deploying a Repository Inside a GitHub Organization to Vercel Using GitHub Actions","publishedDate":"2023-03-28T20:11:00Z","tags":["GitHub","GitHub Actions","Vercel"],"description":"","disableComments":false},"rawContent":"\n[Vercel](https://vercel.com/) is a popular cloud service platform designed for hosting [Next.js](https://nextjs.org/) applications. While it offers free hosting for personal repositories, it doesn't allow deploying from repositories inside a GitHub Organization unless you subscribe to a paid plan.\n\nIn this blog post, we'll create a GitHub Action that duplicates the content of a repository inside a GitHub Organization to a repository in your personal GitHub account, allowing you to leverage Vercel's free hosting services.\n\n> **NOTE**: This approach may not be suitable for all scenarios, and ensuring proper security measures when dealing with sensitive data is essential.\n\n## Prerequisites\n\n- A personal GitHub account\n- A repository within a GitHub Organization (source repository)\n- A separate repository in your personal account to host the copied files (destination repository)\n\n## Step 1: Generate SSH Keys\n\nYou'll need to generate an SSH Deploy Key to securely push your content from the organization's repository to the external repository. Although you can also use a Personal Access Token, an SSH deploy key is recommended as it minimizes the impact of potential security breaches.\n\n```bash\nssh-keygen -t ed25519 -C \"$(git config user.email)\" -N \"\" -f github-<desitination-repo-name>\n```\n\nReplace the `<desitination-repo-name>` with the name of your destination repository and run the command. Afterwards, you should now have both public and private key files:\n\n- `github-<desitination-repo-name>.pub` (public)\n- `github-<desitination-repo-name>` (private)\n\n## Step 2: Add the private key to the Source Repository\n\n1. Visit the source repository's GitHub page.\n2. Click on \"Settings\" in the repository (not account settings).\n3. In the left-hand pane, click \"Secrets\", then \"Actions\".\n4. Click on \"New repository secret\".\n5. Name it `SSH_DEPLOY_KEY` and paste the contents of the private key file.\n6. Click \"Save\".\n\n## Step 3: Add the public key to the Destination Repository\n\n1. Visit the destination repository's GitHub page.\n2. Click on \"Settings\" in the repository (not account settings).\n3. In the left-hand side pane, click on \"Deploy keys.\"\n4. Click on \"Add deploy key\".\n5. Paste the contents of the public key file.\n6. Enable \"Allow write access\".\n7. Click \"Save\".\n\n## Step 4: Disable GitHub Actions on the Destination Repository\n\n1. Visit the destination repository's GitHub page.\n2. Click on \"Settings\" in the repository (not account settings).\n3. Click on \"Actions\" and then \"General\".\n4. Select \"Disable actions\".\n5. Click \"Save\".\n\n## Step 5: Create a GitHub Action Workflow\n\nCreate a new GitHub Action workflow in your source repository by adding a YAML file in the `.github/workflows` directory. Name the file `push-to-external-repo.yml` and paste the following content:\n\n```yaml filename=.github/workflows/push-to-external-repo.yml\nname: (main) push to external repo\non:\n  push:\n    branches:\n      - main\njobs:\n  push-to-external-repo:\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: push to external repository\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.SSH_DEPLOY_KEY }}\n          publish_dir: .\n          external_repository: <your-username>/<destination-repo-name>\n          publish_branch: main\n          allow_empty_commit: true\n```\n\nReplace `<your-username>` with your GitHub username and `<destination-repo-name>` with the name of the external repository in your personal account.\nThis action will copy everything from your organization's repository to your personal repository, including your GitHub Action workflows, so follow [Step 4](#step-4-disable-github-actions-on-the-destination-repository) to disable GitHub Actions on the destination repository.\n\n## Step 6: Run your workflow\n\nPush something to your `main` branch and see it be pushed to your `<your-username>/<destination-repo-name>` repository.\n\n## Step 7: Set up a project on Vercel\n\n1. On Vercel's \"New Project\" page, choose the account linked to the project under the \"Import Git Repository\" section.\n2. Find your personal repository in the list and select \"Import\".\n3. Vercel will automatically detect the framework and any necessary build settings. You can configure project settings, including build and development settings and environment variables, at this stage or later.\n4. Click the \"Deploy\" button. Vercel will create the project and deploy it based on the chosen configurations.\n","excerpt":"\n[Vercel](https://vercel.com/) is a popular cloud service platform designed for hosting [Next.js](https://nextjs.org/) applications. While it offers free hosting for personal repositories, it doesn't allow deploying from repositories inside a GitHub Organization unless you subscribe to a paid plan.\n...","serializedContent":{"compiledSource":"var c=Object.defineProperty,h=Object.defineProperties;var d=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable;var s=(e,t,i)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,o=(e,t)=>{for(var i in t||(t={}))r.call(t,i)&&s(e,i,t[i]);if(a)for(var i of a(t))l.call(t,i)&&s(e,i,t[i]);return e},p=(e,t)=>h(e,d(t));var u=(e,t)=>{var i={};for(var n in e)r.call(e,n)&&t.indexOf(n)<0&&(i[n]=e[n]);if(e!=null&&a)for(var n of a(e))t.indexOf(n)<0&&l.call(e,n)&&(i[n]=e[n]);return i};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var n=i,{components:e}=n,t=u(n,[\"components\"]);return mdx(MDXLayout,p(o(o({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"a\",o({parentName:\"p\"},{href:\"https://vercel.com/\"}),\"Vercel\"),\" is a popular cloud service platform designed for hosting \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://nextjs.org/\"}),\"Next.js\"),\" applications. While it offers free hosting for personal repositories, it doesn't allow deploying from repositories inside a GitHub Organization unless you subscribe to a paid plan.\"),mdx(\"p\",null,\"In this blog post, we'll create a GitHub Action that duplicates the content of a repository inside a GitHub Organization to a repository in your personal GitHub account, allowing you to leverage Vercel's free hosting services.\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": This approach may not be suitable for all scenarios, and ensuring proper security measures when dealing with sensitive data is essential.\")),mdx(\"h2\",o({},{id:\"prerequisites\"}),\"Prerequisites\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"A personal GitHub account\"),mdx(\"li\",{parentName:\"ul\"},\"A repository within a GitHub Organization (source repository)\"),mdx(\"li\",{parentName:\"ul\"},\"A separate repository in your personal account to host the copied files (destination repository)\")),mdx(\"h2\",o({},{id:\"step-1-generate-ssh-keys\"}),\"Step 1: Generate SSH Keys\"),mdx(\"p\",null,\"You'll need to generate an SSH Deploy Key to securely push your content from the organization's repository to the external repository. Although you can also use a Personal Access Token, an SSH deploy key is recommended as it minimizes the impact of potential security breaches.\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-bash\"}),`ssh-keygen -t ed25519 -C \"$(git config user.email)\" -N \"\" -f github-<desitination-repo-name>\n`)),mdx(\"p\",null,\"Replace the \",mdx(\"inlineCode\",{parentName:\"p\"},\"<desitination-repo-name>\"),\" with the name of your destination repository and run the command. Afterwards, you should now have both public and private key files:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"github-<desitination-repo-name>.pub\"),\" (public)\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"github-<desitination-repo-name>\"),\" (private)\")),mdx(\"h2\",o({},{id:\"step-2-add-the-private-key-to-the-source-repository\"}),\"Step 2: Add the private key to the Source Repository\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Visit the source repository's GitHub page.\"),mdx(\"li\",{parentName:\"ol\"},'Click on \"Settings\" in the repository (not account settings).'),mdx(\"li\",{parentName:\"ol\"},'In the left-hand pane, click \"Secrets\", then \"Actions\".'),mdx(\"li\",{parentName:\"ol\"},'Click on \"New repository secret\".'),mdx(\"li\",{parentName:\"ol\"},\"Name it \",mdx(\"inlineCode\",{parentName:\"li\"},\"SSH_DEPLOY_KEY\"),\" and paste the contents of the private key file.\"),mdx(\"li\",{parentName:\"ol\"},'Click \"Save\".')),mdx(\"h2\",o({},{id:\"step-3-add-the-public-key-to-the-destination-repository\"}),\"Step 3: Add the public key to the Destination Repository\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Visit the destination repository's GitHub page.\"),mdx(\"li\",{parentName:\"ol\"},'Click on \"Settings\" in the repository (not account settings).'),mdx(\"li\",{parentName:\"ol\"},'In the left-hand side pane, click on \"Deploy keys.\"'),mdx(\"li\",{parentName:\"ol\"},'Click on \"Add deploy key\".'),mdx(\"li\",{parentName:\"ol\"},\"Paste the contents of the public key file.\"),mdx(\"li\",{parentName:\"ol\"},'Enable \"Allow write access\".'),mdx(\"li\",{parentName:\"ol\"},'Click \"Save\".')),mdx(\"h2\",o({},{id:\"step-4-disable-github-actions-on-the-destination-repository\"}),\"Step 4: Disable GitHub Actions on the Destination Repository\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Visit the destination repository's GitHub page.\"),mdx(\"li\",{parentName:\"ol\"},'Click on \"Settings\" in the repository (not account settings).'),mdx(\"li\",{parentName:\"ol\"},'Click on \"Actions\" and then \"General\".'),mdx(\"li\",{parentName:\"ol\"},'Select \"Disable actions\".'),mdx(\"li\",{parentName:\"ol\"},'Click \"Save\".')),mdx(\"h2\",o({},{id:\"step-5-create-a-github-action-workflow\"}),\"Step 5: Create a GitHub Action Workflow\"),mdx(\"p\",null,\"Create a new GitHub Action workflow in your source repository by adding a YAML file in the \",mdx(\"inlineCode\",{parentName:\"p\"},\".github/workflows\"),\" directory. Name the file \",mdx(\"inlineCode\",{parentName:\"p\"},\"push-to-external-repo.yml\"),\" and paste the following content:\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-yaml\",metastring:\"filename=.github/workflows/push-to-external-repo.yml\",filename:\".github/workflows/push-to-external-repo.yml\"}),`name: (main) push to external repo\non:\n  push:\n    branches:\n      - main\njobs:\n  push-to-external-repo:\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: push to external repository\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: \\${{ secrets.SSH_DEPLOY_KEY }}\n          publish_dir: .\n          external_repository: <your-username>/<destination-repo-name>\n          publish_branch: main\n          allow_empty_commit: true\n`)),mdx(\"p\",null,\"Replace \",mdx(\"inlineCode\",{parentName:\"p\"},\"<your-username>\"),\" with your GitHub username and \",mdx(\"inlineCode\",{parentName:\"p\"},\"<destination-repo-name>\"),` with the name of the external repository in your personal account.\nThis action will copy everything from your organization's repository to your personal repository, including your GitHub Action workflows, so follow `,mdx(\"a\",o({parentName:\"p\"},{href:\"#step-4-disable-github-actions-on-the-destination-repository\"}),\"Step 4\"),\" to disable GitHub Actions on the destination repository.\"),mdx(\"h2\",o({},{id:\"step-6-run-your-workflow\"}),\"Step 6: Run your workflow\"),mdx(\"p\",null,\"Push something to your \",mdx(\"inlineCode\",{parentName:\"p\"},\"main\"),\" branch and see it be pushed to your \",mdx(\"inlineCode\",{parentName:\"p\"},\"<your-username>/<destination-repo-name>\"),\" repository.\"),mdx(\"h2\",o({},{id:\"step-7-set-up-a-project-on-vercel\"}),\"Step 7: Set up a project on Vercel\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},`On Vercel's \"New Project\" page, choose the account linked to the project under the \"Import Git Repository\" section.`),mdx(\"li\",{parentName:\"ol\"},'Find your personal repository in the list and select \"Import\".'),mdx(\"li\",{parentName:\"ol\"},\"Vercel will automatically detect the framework and any necessary build settings. You can configure project settings, including build and development settings and environment variables, at this stage or later.\"),mdx(\"li\",{parentName:\"ol\"},'Click the \"Deploy\" button. Vercel will create the project and deploy it based on the chosen configurations.')))}MDXContent.isMDXComponent=!0;\n","scope":{}}}]},"__N_SSG":true}