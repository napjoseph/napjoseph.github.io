{"pageProps":{"article":{"title":"Manually Create Coverage Badges Using GitHub Actions","layout":"posts","slug":"manually-create-coverage-badges-using-github-actions","draft":false,"frontMatter":{"title":"Manually Create Coverage Badges Using GitHub Actions","publishedDate":"2023-04-09T23:31:00Z","tags":["GitHub","GitHub Actions","Coverage"],"description":"","disableComments":false},"rawContent":"\nAdding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\n\n## Prerequisites\n\n- A [Node.js](https://nodejs.org/) project with test coverage reports generated by a tool like [c8](https://github.com/bcoe/c8) or [Istanbul](https://github.com/istanbuljs/nyc).\n- A GitHub repository for your project.\n- [GitHub deploy keys](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) configured for your repository.\n\nLet's get started!\n\n## Step 1: Install Cheerio\n\nBefore anything else, make sure you have a coverage report generated by your testing tool. In our case, we will use the HTML report generated by [c8](https://github.com/bcoe/c8). This report will look something like this:\n\n```html filename=./coverage/index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <div class=\"wrapper\">\n      <div class=\"pad1\">\n        <div class=\"clearfix\">\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Statements</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Branches</span>\n            <span class=\"fraction\">74/74</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">90.9%</span>\n            <span class=\"quiet\">Functions</span>\n            <span class=\"fraction\">33/33</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Lines</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\nWe will use [cheerio](https://github.com/cheeriojs/cheerio), a [jQuery](https://jquery.com/)-like library for server-side to extract the percentage data from the HTML. Install it to your `devDependencies` using the package manager of your choice:\n\n```bash\n# npm\nnpm install --save-dev cheerio\n\n# yarn\nyarn add --dev cheerio\n\n# pnpm\npnpm add --save-dev cheerio\n```\n\n## Step 2: Create a Script to Extract Coverage Data\n\nNext, we need to create the actual script that will extract the coverage data from the HTML report. Create a new file called `./scripts/generate-badges.js` and add the following code:\n\n```js filename=./scripts/generate-badges.js\nconst fs = require('fs');\nconst https = require('https');\nconst cheerio = require('cheerio');\n\nconst coverageFile = './coverage/index.html';\nconst badgesDir = './coverage/badges';\n\n// Read the coverage HTML file.\nfs.readFile(coverageFile, 'utf-8', (err, data) => {\n  if (err) {\n    console.error(`Error reading coverage file: ${err}`);\n    process.exit(1);\n  }\n\n  // Parse the HTML using Cheerio.\n  const $ = cheerio.load(data);\n\n  // Construct the shields.io URL for each badge.\n  const statementsBadgeUrl = generateUrl('statements', extractPercentage($, 1));\n  const branchesBadgeUrl = generateUrl('branches', extractPercentage($, 2));\n  const functionsBadgeUrl = generateUrl('functions', extractPercentage($, 3));\n  const linesBadgeUrl = generateUrl('lines', extractPercentage($, 4));\n\n  // Create the badges directory if it does not exist.\n  if (!fs.existsSync(badgesDir)) {\n    fs.mkdirSync(badgesDir);\n  }\n\n  // Download each badge and save it to the badges directory.\n  downloadBadge(statementsBadgeUrl, `${badgesDir}/statements.svg`);\n  downloadBadge(branchesBadgeUrl, `${badgesDir}/branches.svg`);\n  downloadBadge(functionsBadgeUrl, `${badgesDir}/functions.svg`);\n  downloadBadge(linesBadgeUrl, `${badgesDir}/lines.svg`);\n\n  console.log('Code coverage badges created successfully.');\n});\n\n/**\n * Generate a shields.io URL for a badge.\n *\n * Change the color of the badge based on the percentage.\n *\n * @param {string} text The text to display on the badge.\n * @param {number} percentage The percentage to display on the badge.\n * @returns {string} The shields.io URL.\n */\nconst generateUrl = (text, percentage) => {\n  let color = 'brightgreen';\n  if (percentage < 70) {\n    color = 'red';\n  } else if (percentage < 80) {\n    color = 'yellow';\n  } else if (percentage < 90) {\n    color = 'orange';\n  }\n  return `https://img.shields.io/badge/coverage%3A${text}-${percentage}%25-${color}.svg`;\n};\n\n/**\n * Extract the code coverage percentage from the HTML.\n * @param {Cheerio} $ The Cheerio object.\n * @param {number} index The index of the element to extract.\n */\nconst extractPercentage = ($, index) => {\n  const text = $(`.pad1y:nth-child(${index}) span.strong`) ?? '0';\n  const percentage = text.text().trim().replace('%', '');\n  return parseFloat(percentage);\n};\n\n/**\n * Download a badge from shields.io.\n * @param {string} url The shields.io URL.\n * @param {string} filename The filename to save the badge to.\n */\nconst downloadBadge = (url, filename) => {\n  https.get(url, (res) => {\n    if (res.statusCode !== 200) {\n      console.error(`Error downloading badge: ${res.statusMessage}`);\n      return;\n    }\n\n    const file = fs.createWriteStream(filename);\n    res.pipe(file);\n    file.on('finish', () => {\n      file.close();\n    });\n  });\n};\n```\n\nThis is a fairly straightforward script that uses Cheerio to parse the HTML report and extract the coverage data. It then uses the data to generate the [shields.io](https://shields.io/) URLs for each badge type. Finally, it downloads each badge and saves it to the `./coverage/badges` directory.\n\nUpdate your `package.json` to add a new script that will run the `generate-badges.js` script:\n\n```json filename=package.json\n{\n  \"scripts\": {\n    // ...\n    \"generate-badges\": \"node ./scripts/generate-badges.js\"\n  }\n}\n```\n\nRun the script to generate the badges:\n\n```bash\n# generate the coverage report first\npnpm coverage\n\n# generate the badges\npnpm generate-badges\n```\n\n## Step 3: Configure GitHub Actions\n\n> **NOTE**: For this guide, we will use [pnpm](https://pnpm.io/), but the commands should be similar for other package managers.\n\n> **NOTE**: This requires that you have an SSH Deploy Key configured for your repository. See [Create SSH Deploy Key](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) for more information.\n\nIn your repository, create a `.github/workflows` directory if it doesn't already exist. Then, create a new YAML file inside the workflows directory called `coverage-badge.yml`. This file will define the GitHub Actions workflow that generates the coverage badge.\n\nAdd the following content to `coverage-badge.yml`:\n\n```yaml filename=.github/workflows/coverage-badge.yml\nname: (main) coverage badge\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage-badge:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: setup node\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node }}\n      - name: install pnpm\n        uses: pnpm/action-setup@v2\n        id: pnpm-install\n        with:\n          version: ${{ matrix.pnpm }}\n          run_install: false\n      - name: get pnpm store directory\n        id: pnpm-cache\n        shell: bash\n        run: |\n          echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n      - name: Setup pnpm cache\n        uses: actions/cache@v3\n        with:\n          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}\n          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-pnpm-store-\n      - name: install dependencies\n        run: pnpm install\n      - name: run coverage\n        run: pnpm coverage\n      - name: generate badges\n        run: pnpm generate-badges\n      - name: push coverage artifacts to another branch\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.COVERAGE_DEPLOY_KEY }}\n          publish_dir: ./coverage\n          publish_branch: coverage\n          allow_empty_commit: true\n```\n\nLet's break down the workflow into its various sections:\n\n```yaml\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n```\n\nThe workflow is triggered when there's a push to the `main` branch or can be triggered manually ([`workflow_dispatch`](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch)).\n\n```yaml\njobs:\n  covera:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: ${{ matrix.os }}\n```\n\nWe're using a matrix strategy to run the workflow on multiple operating systems, Node.js versions, and pnpm versions. For our purpose, we will only use one version of each, but this is a good practice to follow.\n\n```yaml\n- name: checkout repository\n  uses: actions/checkout@v3\n- name: setup node\n  uses: actions/setup-node@v3\n  with:\n    node-version: ${{ matrix.node }}\n```\n\nThis step checks out your repository using the [actions/checkout](https://github.com/actions/checkout) action. Then, it sets up Node.js using the [actions/setup-node](https://github.com/actions/setup-node) action.\n\n```yaml\n- name: install pnpm\n  uses: pnpm/action-setup@v2\n  id: pnpm-install\n  with:\n    version: ${{ matrix.pnpm }}\n    run_install: false\n```\n\nThis step installs pnpm using the [pnpm/action-setup](https://github.com/pnpm/action-setup) action and the specified pnpm version from the matrix. We're not installing any dependencies yet, so we don't need to run `pnpm install`.\n\n```yaml\n- name: get pnpm store directory\n  id: pnpm-cache\n  shell: bash\n  run: |\n    echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n- name: Setup pnpm cache\n  uses: actions/cache@v3\n  with:\n    path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}\n    key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}\n    restore-keys: |\n      ${{ runner.os }}-pnpm-store-\n- name: install dependencies\n  run: pnpm install\n```\n\nThese steps will use the cache from [actions/cache](https://github.com/actions/cache) and install the project's dependencies using pnpm. We're using the cache to reduce installation time and to avoid downloading the same dependencies multiple times.\n\n```yaml\n- name: run coverage\n  run: pnpm coverage\n- name: generate badges\n  run: pnpm generate-badges\n```\n\nThis step runs the `coverage` script, which should generate a coverage report. Then, it runs the `generate-badges` script, which should generate the coverage badges.\n\n```yaml\n- name: push coverage artifacts to another branch\n  uses: peaceiris/actions-gh-pages@v3\n  with:\n    deploy_key: ${{ secrets.COVERAGE_DEPLOY_KEY }}\n    publish_dir: ./coverage\n    publish_branch: coverage\n    allow_empty_commit: true\n```\n\nLastly, this step pushes the coverage artifacts, including the generated badges and the coverage report, to a separate coverage branch in your repository using the [peaceiris/actions-gh-pages](https://github.com/peaceiris/actions-gh-pages) action.\n\nOptions:\n\n- The `deploy_key` option is set to the `COVERAGE_DEPLOY_KEY` secret, which is a Deploy Key stored in your repository settings. This deploy key should have write access to the repository. Follow the instructions from [Create SSH Deploy Key](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) to generate it and add it to your repository.\n- The `publish_dir` is set to `./coverage`, which is the directory containing the coverage report and badges.\n- The `allow_empty_commit` option is set to true to allow empty commits if there are no changes in the coverage artifacts.\n- The `publish_branch` is the name of the branch you want to push the coverage artifacts to. It's currently set to `coverage`, but you can change it to whatever you want.\n\n## Step 4: Add Badge to README\n\nTo display the coverage badge in your README file, add the following line at the top of your `README.md` file:\n\n```md filename=README.md\n![Coverage: Statements](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/statements.svg)\n![Coverage: Branches](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/branches.svg)\n![Coverage: Functions](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/functions.svg)\n![Coverage: Lines](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/lines.svg)\n```\n\nThese lines will render the badges as an image. It should point to the latest badges in your `<PUBLISH_BRANCH_NAME>` branch.\n\n## Conclusion\n\nCongratulations! You have successfully created a dynamic coverage badge for your Node.js project. This badge will help you showcase your project's test coverage and encourage you to maintain a high level of code quality. Don't hesitate to customize this workflow to suit your needs and adapt it to different coverage tools and badge styles.\n\nHappy coding!\n","excerpt":"\nAdding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\n\n##...","serializedContent":{"compiledSource":"var d=Object.defineProperty,h=Object.defineProperties;var g=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var p=(a,t,n)=>t in a?d(a,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):a[t]=n,e=(a,t)=>{for(var n in t||(t={}))o.call(t,n)&&p(a,n,t[n]);if(s)for(var n of s(t))i.call(t,n)&&p(a,n,t[n]);return a},c=(a,t)=>h(a,g(t));var l=(a,t)=>{var n={};for(var r in a)o.call(a,r)&&t.indexOf(r)<0&&(n[r]=a[r]);if(a!=null&&s)for(var r of s(a))t.indexOf(r)<0&&i.call(a,r)&&(n[r]=a[r]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var r=n,{components:a}=r,t=l(r,[\"components\"]);return mdx(MDXLayout,c(e(e({},layoutProps),t),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Adding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\"),mdx(\"h2\",e({},{id:\"prerequisites\"}),\"Prerequisites\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"A \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://nodejs.org/\"}),\"Node.js\"),\" project with test coverage reports generated by a tool like \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/bcoe/c8\"}),\"c8\"),\" or \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/istanbuljs/nyc\"}),\"Istanbul\"),\".\"),mdx(\"li\",{parentName:\"ul\"},\"A GitHub repository for your project.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"GitHub deploy keys\"),\" configured for your repository.\")),mdx(\"p\",null,\"Let's get started!\"),mdx(\"h2\",e({},{id:\"step-1-install-cheerio\"}),\"Step 1: Install Cheerio\"),mdx(\"p\",null,\"Before anything else, make sure you have a coverage report generated by your testing tool. In our case, we will use the HTML report generated by \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/bcoe/c8\"}),\"c8\"),\". This report will look something like this:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-html\",metastring:\"filename=./coverage/index.html\",filename:\"./coverage/index.html\"}),`<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <div class=\"wrapper\">\n      <div class=\"pad1\">\n        <div class=\"clearfix\">\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Statements</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Branches</span>\n            <span class=\"fraction\">74/74</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">90.9%</span>\n            <span class=\"quiet\">Functions</span>\n            <span class=\"fraction\">33/33</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Lines</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n`)),mdx(\"p\",null,\"We will use \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/cheeriojs/cheerio\"}),\"cheerio\"),\", a \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://jquery.com/\"}),\"jQuery\"),\"-like library for server-side to extract the percentage data from the HTML. Install it to your \",mdx(\"inlineCode\",{parentName:\"p\"},\"devDependencies\"),\" using the package manager of your choice:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-bash\"}),`# npm\nnpm install --save-dev cheerio\n\n# yarn\nyarn add --dev cheerio\n\n# pnpm\npnpm add --save-dev cheerio\n`)),mdx(\"h2\",e({},{id:\"step-2-create-a-script-to-extract-coverage-data\"}),\"Step 2: Create a Script to Extract Coverage Data\"),mdx(\"p\",null,\"Next, we need to create the actual script that will extract the coverage data from the HTML report. Create a new file called \",mdx(\"inlineCode\",{parentName:\"p\"},\"./scripts/generate-badges.js\"),\" and add the following code:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\",metastring:\"filename=./scripts/generate-badges.js\",filename:\"./scripts/generate-badges.js\"}),`const fs = require('fs');\nconst https = require('https');\nconst cheerio = require('cheerio');\n\nconst coverageFile = './coverage/index.html';\nconst badgesDir = './coverage/badges';\n\n// Read the coverage HTML file.\nfs.readFile(coverageFile, 'utf-8', (err, data) => {\n  if (err) {\n    console.error(\\`Error reading coverage file: \\${err}\\`);\n    process.exit(1);\n  }\n\n  // Parse the HTML using Cheerio.\n  const $ = cheerio.load(data);\n\n  // Construct the shields.io URL for each badge.\n  const statementsBadgeUrl = generateUrl('statements', extractPercentage($, 1));\n  const branchesBadgeUrl = generateUrl('branches', extractPercentage($, 2));\n  const functionsBadgeUrl = generateUrl('functions', extractPercentage($, 3));\n  const linesBadgeUrl = generateUrl('lines', extractPercentage($, 4));\n\n  // Create the badges directory if it does not exist.\n  if (!fs.existsSync(badgesDir)) {\n    fs.mkdirSync(badgesDir);\n  }\n\n  // Download each badge and save it to the badges directory.\n  downloadBadge(statementsBadgeUrl, \\`\\${badgesDir}/statements.svg\\`);\n  downloadBadge(branchesBadgeUrl, \\`\\${badgesDir}/branches.svg\\`);\n  downloadBadge(functionsBadgeUrl, \\`\\${badgesDir}/functions.svg\\`);\n  downloadBadge(linesBadgeUrl, \\`\\${badgesDir}/lines.svg\\`);\n\n  console.log('Code coverage badges created successfully.');\n});\n\n/**\n * Generate a shields.io URL for a badge.\n *\n * Change the color of the badge based on the percentage.\n *\n * @param {string} text The text to display on the badge.\n * @param {number} percentage The percentage to display on the badge.\n * @returns {string} The shields.io URL.\n */\nconst generateUrl = (text, percentage) => {\n  let color = 'brightgreen';\n  if (percentage < 70) {\n    color = 'red';\n  } else if (percentage < 80) {\n    color = 'yellow';\n  } else if (percentage < 90) {\n    color = 'orange';\n  }\n  return \\`https://img.shields.io/badge/coverage%3A\\${text}-\\${percentage}%25-\\${color}.svg\\`;\n};\n\n/**\n * Extract the code coverage percentage from the HTML.\n * @param {Cheerio} $ The Cheerio object.\n * @param {number} index The index of the element to extract.\n */\nconst extractPercentage = ($, index) => {\n  const text = $(\\`.pad1y:nth-child(\\${index}) span.strong\\`) ?? '0';\n  const percentage = text.text().trim().replace('%', '');\n  return parseFloat(percentage);\n};\n\n/**\n * Download a badge from shields.io.\n * @param {string} url The shields.io URL.\n * @param {string} filename The filename to save the badge to.\n */\nconst downloadBadge = (url, filename) => {\n  https.get(url, (res) => {\n    if (res.statusCode !== 200) {\n      console.error(\\`Error downloading badge: \\${res.statusMessage}\\`);\n      return;\n    }\n\n    const file = fs.createWriteStream(filename);\n    res.pipe(file);\n    file.on('finish', () => {\n      file.close();\n    });\n  });\n};\n`)),mdx(\"p\",null,\"This is a fairly straightforward script that uses Cheerio to parse the HTML report and extract the coverage data. It then uses the data to generate the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://shields.io/\"}),\"shields.io\"),\" URLs for each badge type. Finally, it downloads each badge and saves it to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"./coverage/badges\"),\" directory.\"),mdx(\"p\",null,\"Update your \",mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\"),\" to add a new script that will run the \",mdx(\"inlineCode\",{parentName:\"p\"},\"generate-badges.js\"),\" script:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\",metastring:\"filename=package.json\",filename:\"package.json\"}),`{\n  \"scripts\": {\n    // ...\n    \"generate-badges\": \"node ./scripts/generate-badges.js\"\n  }\n}\n`)),mdx(\"p\",null,\"Run the script to generate the badges:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-bash\"}),`# generate the coverage report first\npnpm coverage\n\n# generate the badges\npnpm generate-badges\n`)),mdx(\"h2\",e({},{id:\"step-3-configure-github-actions\"}),\"Step 3: Configure GitHub Actions\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": For this guide, we will use \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://pnpm.io/\"}),\"pnpm\"),\", but the commands should be similar for other package managers.\")),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": This requires that you have an SSH Deploy Key configured for your repository. See \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"Create SSH Deploy Key\"),\" for more information.\")),mdx(\"p\",null,\"In your repository, create a \",mdx(\"inlineCode\",{parentName:\"p\"},\".github/workflows\"),\" directory if it doesn't already exist. Then, create a new YAML file inside the workflows directory called \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage-badge.yml\"),\". This file will define the GitHub Actions workflow that generates the coverage badge.\"),mdx(\"p\",null,\"Add the following content to \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage-badge.yml\"),\":\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\",metastring:\"filename=.github/workflows/coverage-badge.yml\",filename:\".github/workflows/coverage-badge.yml\"}),`name: (main) coverage badge\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage-badge:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: \\${{ matrix.os }}\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: setup node\n        uses: actions/setup-node@v3\n        with:\n          node-version: \\${{ matrix.node }}\n      - name: install pnpm\n        uses: pnpm/action-setup@v2\n        id: pnpm-install\n        with:\n          version: \\${{ matrix.pnpm }}\n          run_install: false\n      - name: get pnpm store directory\n        id: pnpm-cache\n        shell: bash\n        run: |\n          echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n      - name: Setup pnpm cache\n        uses: actions/cache@v3\n        with:\n          path: \\${{ steps.pnpm-cache.outputs.STORE_PATH }}\n          key: \\${{ runner.os }}-pnpm-store-\\${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            \\${{ runner.os }}-pnpm-store-\n      - name: install dependencies\n        run: pnpm install\n      - name: run coverage\n        run: pnpm coverage\n      - name: generate badges\n        run: pnpm generate-badges\n      - name: push coverage artifacts to another branch\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: \\${{ secrets.COVERAGE_DEPLOY_KEY }}\n          publish_dir: ./coverage\n          publish_branch: coverage\n          allow_empty_commit: true\n`)),mdx(\"p\",null,\"Let's break down the workflow into its various sections:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`on:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n`)),mdx(\"p\",null,\"The workflow is triggered when there's a push to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"main\"),\" branch or can be triggered manually (\",mdx(\"a\",e({parentName:\"p\"},{href:\"https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch\"}),mdx(\"inlineCode\",{parentName:\"a\"},\"workflow_dispatch\")),\").\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`jobs:\n  covera:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: \\${{ matrix.os }}\n`)),mdx(\"p\",null,\"We're using a matrix strategy to run the workflow on multiple operating systems, Node.js versions, and pnpm versions. For our purpose, we will only use one version of each, but this is a good practice to follow.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: checkout repository\n  uses: actions/checkout@v3\n- name: setup node\n  uses: actions/setup-node@v3\n  with:\n    node-version: \\${{ matrix.node }}\n`)),mdx(\"p\",null,\"This step checks out your repository using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/checkout\"}),\"actions/checkout\"),\" action. Then, it sets up Node.js using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/setup-node\"}),\"actions/setup-node\"),\" action.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: install pnpm\n  uses: pnpm/action-setup@v2\n  id: pnpm-install\n  with:\n    version: \\${{ matrix.pnpm }}\n    run_install: false\n`)),mdx(\"p\",null,\"This step installs pnpm using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/pnpm/action-setup\"}),\"pnpm/action-setup\"),\" action and the specified pnpm version from the matrix. We're not installing any dependencies yet, so we don't need to run \",mdx(\"inlineCode\",{parentName:\"p\"},\"pnpm install\"),\".\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: get pnpm store directory\n  id: pnpm-cache\n  shell: bash\n  run: |\n    echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n- name: Setup pnpm cache\n  uses: actions/cache@v3\n  with:\n    path: \\${{ steps.pnpm-cache.outputs.STORE_PATH }}\n    key: \\${{ runner.os }}-pnpm-store-\\${{ hashFiles('**/pnpm-lock.yaml') }}\n    restore-keys: |\n      \\${{ runner.os }}-pnpm-store-\n- name: install dependencies\n  run: pnpm install\n`)),mdx(\"p\",null,\"These steps will use the cache from \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/cache\"}),\"actions/cache\"),\" and install the project's dependencies using pnpm. We're using the cache to reduce installation time and to avoid downloading the same dependencies multiple times.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: run coverage\n  run: pnpm coverage\n- name: generate badges\n  run: pnpm generate-badges\n`)),mdx(\"p\",null,\"This step runs the \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage\"),\" script, which should generate a coverage report. Then, it runs the \",mdx(\"inlineCode\",{parentName:\"p\"},\"generate-badges\"),\" script, which should generate the coverage badges.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: push coverage artifacts to another branch\n  uses: peaceiris/actions-gh-pages@v3\n  with:\n    deploy_key: \\${{ secrets.COVERAGE_DEPLOY_KEY }}\n    publish_dir: ./coverage\n    publish_branch: coverage\n    allow_empty_commit: true\n`)),mdx(\"p\",null,\"Lastly, this step pushes the coverage artifacts, including the generated badges and the coverage report, to a separate coverage branch in your repository using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/peaceiris/actions-gh-pages\"}),\"peaceiris/actions-gh-pages\"),\" action.\"),mdx(\"p\",null,\"Options:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"deploy_key\"),\" option is set to the \",mdx(\"inlineCode\",{parentName:\"li\"},\"COVERAGE_DEPLOY_KEY\"),\" secret, which is a Deploy Key stored in your repository settings. This deploy key should have write access to the repository. Follow the instructions from \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"Create SSH Deploy Key\"),\" to generate it and add it to your repository.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"publish_dir\"),\" is set to \",mdx(\"inlineCode\",{parentName:\"li\"},\"./coverage\"),\", which is the directory containing the coverage report and badges.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"allow_empty_commit\"),\" option is set to true to allow empty commits if there are no changes in the coverage artifacts.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"publish_branch\"),\" is the name of the branch you want to push the coverage artifacts to. It's currently set to \",mdx(\"inlineCode\",{parentName:\"li\"},\"coverage\"),\", but you can change it to whatever you want.\")),mdx(\"h2\",e({},{id:\"step-4-add-badge-to-readme\"}),\"Step 4: Add Badge to README\"),mdx(\"p\",null,\"To display the coverage badge in your README file, add the following line at the top of your \",mdx(\"inlineCode\",{parentName:\"p\"},\"README.md\"),\" file:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-md\",metastring:\"filename=README.md\",filename:\"README.md\"}),`![Coverage: Statements](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/statements.svg)\n![Coverage: Branches](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/branches.svg)\n![Coverage: Functions](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/functions.svg)\n![Coverage: Lines](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/lines.svg)\n`)),mdx(\"p\",null,\"These lines will render the badges as an image. It should point to the latest badges in your \",mdx(\"inlineCode\",{parentName:\"p\"},\"<PUBLISH_BRANCH_NAME>\"),\" branch.\"),mdx(\"h2\",e({},{id:\"conclusion\"}),\"Conclusion\"),mdx(\"p\",null,\"Congratulations! You have successfully created a dynamic coverage badge for your Node.js project. This badge will help you showcase your project's test coverage and encourage you to maintain a high level of code quality. Don't hesitate to customize this workflow to suit your needs and adapt it to different coverage tools and badge styles.\"),mdx(\"p\",null,\"Happy coding!\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}}},"__N_SSG":true}