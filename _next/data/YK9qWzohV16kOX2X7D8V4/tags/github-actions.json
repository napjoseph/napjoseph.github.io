{"pageProps":{"tag":{"name":"GitHub Actions","slug":"github-actions"},"articles":[{"title":"Manually Create Coverage Badges Using GitHub Actions","layout":"posts","slug":"manually-create-coverage-badges-using-github-actions","draft":false,"frontMatter":{"title":"Manually Create Coverage Badges Using GitHub Actions","publishedDate":"2023-04-09T23:31:00Z","tags":["GitHub","GitHub Actions","Coverage"],"description":"","disableComments":false},"rawContent":"\nAdding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\n\n## Prerequisites\n\n- A [Node.js](https://nodejs.org/) project with test coverage reports generated by a tool like [c8](https://github.com/bcoe/c8) or [Istanbul](https://github.com/istanbuljs/nyc).\n- A GitHub repository for your project.\n- [GitHub deploy keys](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) configured for your repository.\n\nLet's get started!\n\n## Step 1: Install Cheerio\n\nBefore anything else, make sure you have a coverage report generated by your testing tool. In our case, we will use the HTML report generated by [c8](https://github.com/bcoe/c8). This report will look something like this:\n\n```html filename=./coverage/index.html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <div class=\"wrapper\">\n      <div class=\"pad1\">\n        <div class=\"clearfix\">\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Statements</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Branches</span>\n            <span class=\"fraction\">74/74</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">90.9%</span>\n            <span class=\"quiet\">Functions</span>\n            <span class=\"fraction\">33/33</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Lines</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n```\n\nWe will use [cheerio](https://github.com/cheeriojs/cheerio), a [jQuery](https://jquery.com/)-like library for server-side to extract the percentage data from the HTML. Install it to your `devDependencies` using the package manager of your choice:\n\n```bash\n# npm\nnpm install --save-dev cheerio\n\n# yarn\nyarn add --dev cheerio\n\n# pnpm\npnpm add --save-dev cheerio\n```\n\n## Step 2: Create a Script to Extract Coverage Data\n\nNext, we need to create the actual script that will extract the coverage data from the HTML report. Create a new file called `./scripts/generate-badges.js` and add the following code:\n\n```js filename=./scripts/generate-badges.js\nconst fs = require('fs');\nconst https = require('https');\nconst cheerio = require('cheerio');\n\nconst coverageFile = './coverage/index.html';\nconst badgesDir = './coverage/badges';\n\n// Read the coverage HTML file.\nfs.readFile(coverageFile, 'utf-8', (err, data) => {\n  if (err) {\n    console.error(`Error reading coverage file: ${err}`);\n    process.exit(1);\n  }\n\n  // Parse the HTML using Cheerio.\n  const $ = cheerio.load(data);\n\n  // Construct the shields.io URL for each badge.\n  const statementsBadgeUrl = generateUrl('statements', extractPercentage($, 1));\n  const branchesBadgeUrl = generateUrl('branches', extractPercentage($, 2));\n  const functionsBadgeUrl = generateUrl('functions', extractPercentage($, 3));\n  const linesBadgeUrl = generateUrl('lines', extractPercentage($, 4));\n\n  // Create the badges directory if it does not exist.\n  if (!fs.existsSync(badgesDir)) {\n    fs.mkdirSync(badgesDir);\n  }\n\n  // Download each badge and save it to the badges directory.\n  downloadBadge(statementsBadgeUrl, `${badgesDir}/statements.svg`);\n  downloadBadge(branchesBadgeUrl, `${badgesDir}/branches.svg`);\n  downloadBadge(functionsBadgeUrl, `${badgesDir}/functions.svg`);\n  downloadBadge(linesBadgeUrl, `${badgesDir}/lines.svg`);\n\n  console.log('Code coverage badges created successfully.');\n});\n\n/**\n * Generate a shields.io URL for a badge.\n *\n * Change the color of the badge based on the percentage.\n *\n * @param {string} text The text to display on the badge.\n * @param {number} percentage The percentage to display on the badge.\n * @returns {string} The shields.io URL.\n */\nconst generateUrl = (text, percentage) => {\n  let color = 'brightgreen';\n  if (percentage < 70) {\n    color = 'red';\n  } else if (percentage < 80) {\n    color = 'yellow';\n  } else if (percentage < 90) {\n    color = 'orange';\n  }\n  return `https://img.shields.io/badge/coverage%3A${text}-${percentage}%25-${color}.svg`;\n};\n\n/**\n * Extract the code coverage percentage from the HTML.\n * @param {Cheerio} $ The Cheerio object.\n * @param {number} index The index of the element to extract.\n */\nconst extractPercentage = ($, index) => {\n  const text = $(`.pad1y:nth-child(${index}) span.strong`) ?? '0';\n  const percentage = text.text().trim().replace('%', '');\n  return parseFloat(percentage);\n};\n\n/**\n * Download a badge from shields.io.\n * @param {string} url The shields.io URL.\n * @param {string} filename The filename to save the badge to.\n */\nconst downloadBadge = (url, filename) => {\n  https.get(url, (res) => {\n    if (res.statusCode !== 200) {\n      console.error(`Error downloading badge: ${res.statusMessage}`);\n      return;\n    }\n\n    const file = fs.createWriteStream(filename);\n    res.pipe(file);\n    file.on('finish', () => {\n      file.close();\n    });\n  });\n};\n```\n\nThis is a fairly straightforward script that uses Cheerio to parse the HTML report and extract the coverage data. It then uses the data to generate the [shields.io](https://shields.io/) URLs for each badge type. Finally, it downloads each badge and saves it to the `./coverage/badges` directory.\n\nUpdate your `package.json` to add a new script that will run the `generate-badges.js` script:\n\n```json filename=package.json\n{\n  \"scripts\": {\n    // ...\n    \"generate-badges\": \"node ./scripts/generate-badges.js\"\n  }\n}\n```\n\nRun the script to generate the badges:\n\n```bash\n# generate the coverage report first\npnpm coverage\n\n# generate the badges\npnpm generate-badges\n```\n\n## Step 3: Configure GitHub Actions\n\n> **NOTE**: For this guide, we will use [pnpm](https://pnpm.io/), but the commands should be similar for other package managers.\n\n> **NOTE**: This requires that you have an SSH Deploy Key configured for your repository. See [Create SSH Deploy Key](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) for more information.\n\nIn your repository, create a `.github/workflows` directory if it doesn't already exist. Then, create a new YAML file inside the workflows directory called `coverage-badge.yml`. This file will define the GitHub Actions workflow that generates the coverage badge.\n\nAdd the following content to `coverage-badge.yml`:\n\n```yaml filename=.github/workflows/coverage-badge.yml\nname: (main) coverage badge\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage-badge:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: setup node\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node }}\n      - name: install pnpm\n        uses: pnpm/action-setup@v2\n        id: pnpm-install\n        with:\n          version: ${{ matrix.pnpm }}\n          run_install: false\n      - name: get pnpm store directory\n        id: pnpm-cache\n        shell: bash\n        run: |\n          echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n      - name: Setup pnpm cache\n        uses: actions/cache@v3\n        with:\n          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}\n          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            ${{ runner.os }}-pnpm-store-\n      - name: install dependencies\n        run: pnpm install\n      - name: run coverage\n        run: pnpm coverage\n      - name: generate badges\n        run: pnpm generate-badges\n      - name: push coverage artifacts to another branch\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.COVERAGE_DEPLOY_KEY }}\n          publish_dir: ./coverage\n          publish_branch: coverage\n          allow_empty_commit: true\n```\n\nLet's break down the workflow into its various sections:\n\n```yaml\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n```\n\nThe workflow is triggered when there's a push to the `main` branch or can be triggered manually ([`workflow_dispatch`](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch)).\n\n```yaml\njobs:\n  covera:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: ${{ matrix.os }}\n```\n\nWe're using a matrix strategy to run the workflow on multiple operating systems, Node.js versions, and pnpm versions. For our purpose, we will only use one version of each, but this is a good practice to follow.\n\n```yaml\n- name: checkout repository\n  uses: actions/checkout@v3\n- name: setup node\n  uses: actions/setup-node@v3\n  with:\n    node-version: ${{ matrix.node }}\n```\n\nThis step checks out your repository using the [actions/checkout](https://github.com/actions/checkout) action. Then, it sets up Node.js using the [actions/setup-node](https://github.com/actions/setup-node) action.\n\n```yaml\n- name: install pnpm\n  uses: pnpm/action-setup@v2\n  id: pnpm-install\n  with:\n    version: ${{ matrix.pnpm }}\n    run_install: false\n```\n\nThis step installs pnpm using the [pnpm/action-setup](https://github.com/pnpm/action-setup) action and the specified pnpm version from the matrix. We're not installing any dependencies yet, so we don't need to run `pnpm install`.\n\n```yaml\n- name: get pnpm store directory\n  id: pnpm-cache\n  shell: bash\n  run: |\n    echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n- name: Setup pnpm cache\n  uses: actions/cache@v3\n  with:\n    path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}\n    key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}\n    restore-keys: |\n      ${{ runner.os }}-pnpm-store-\n- name: install dependencies\n  run: pnpm install\n```\n\nThese steps will use the cache from [actions/cache](https://github.com/actions/cache) and install the project's dependencies using pnpm. We're using the cache to reduce installation time and to avoid downloading the same dependencies multiple times.\n\n```yaml\n- name: run coverage\n  run: pnpm coverage\n- name: generate badges\n  run: pnpm generate-badges\n```\n\nThis step runs the `coverage` script, which should generate a coverage report. Then, it runs the `generate-badges` script, which should generate the coverage badges.\n\n```yaml\n- name: push coverage artifacts to another branch\n  uses: peaceiris/actions-gh-pages@v3\n  with:\n    deploy_key: ${{ secrets.COVERAGE_DEPLOY_KEY }}\n    publish_dir: ./coverage\n    publish_branch: coverage\n    allow_empty_commit: true\n```\n\nLastly, this step pushes the coverage artifacts, including the generated badges and the coverage report, to a separate coverage branch in your repository using the [peaceiris/actions-gh-pages](https://github.com/peaceiris/actions-gh-pages) action.\n\nOptions:\n\n- The `deploy_key` option is set to the `COVERAGE_DEPLOY_KEY` secret, which is a Deploy Key stored in your repository settings. This deploy key should have write access to the repository. Follow the instructions from [Create SSH Deploy Key](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key) to generate it and add it to your repository.\n- The `publish_dir` is set to `./coverage`, which is the directory containing the coverage report and badges.\n- The `allow_empty_commit` option is set to true to allow empty commits if there are no changes in the coverage artifacts.\n- The `publish_branch` is the name of the branch you want to push the coverage artifacts to. It's currently set to `coverage`, but you can change it to whatever you want.\n\n## Step 4: Add Badge to README\n\nTo display the coverage badge in your README file, add the following line at the top of your `README.md` file:\n\n```md filename=README.md\n![Coverage: Statements](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/statements.svg)\n![Coverage: Branches](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/branches.svg)\n![Coverage: Functions](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/functions.svg)\n![Coverage: Lines](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/lines.svg)\n```\n\nThese lines will render the badges as an image. It should point to the latest badges in your `<PUBLISH_BRANCH_NAME>` branch.\n\n## Conclusion\n\nCongratulations! You have successfully created a dynamic coverage badge for your Node.js project. This badge will help you showcase your project's test coverage and encourage you to maintain a high level of code quality. Don't hesitate to customize this workflow to suit your needs and adapt it to different coverage tools and badge styles.\n\nHappy coding!\n","excerpt":"\nAdding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\n\n##...","serializedContent":{"compiledSource":"var d=Object.defineProperty,h=Object.defineProperties;var g=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var p=(a,t,n)=>t in a?d(a,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):a[t]=n,e=(a,t)=>{for(var n in t||(t={}))o.call(t,n)&&p(a,n,t[n]);if(s)for(var n of s(t))i.call(t,n)&&p(a,n,t[n]);return a},c=(a,t)=>h(a,g(t));var l=(a,t)=>{var n={};for(var r in a)o.call(a,r)&&t.indexOf(r)<0&&(n[r]=a[r]);if(a!=null&&s)for(var r of s(a))t.indexOf(r)<0&&i.call(a,r)&&(n[r]=a[r]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var r=n,{components:a}=r,t=l(r,[\"components\"]);return mdx(MDXLayout,c(e(e({},layoutProps),t),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Adding a coverage badge to your repository is an excellent way to demonstrate your project's test coverage and maintain a high level of code quality. By the end of this guide, you will be able to generate a dynamic coverage badge that updates automatically with each new push to your repository.\"),mdx(\"h2\",e({},{id:\"prerequisites\"}),\"Prerequisites\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"A \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://nodejs.org/\"}),\"Node.js\"),\" project with test coverage reports generated by a tool like \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/bcoe/c8\"}),\"c8\"),\" or \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/istanbuljs/nyc\"}),\"Istanbul\"),\".\"),mdx(\"li\",{parentName:\"ul\"},\"A GitHub repository for your project.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"GitHub deploy keys\"),\" configured for your repository.\")),mdx(\"p\",null,\"Let's get started!\"),mdx(\"h2\",e({},{id:\"step-1-install-cheerio\"}),\"Step 1: Install Cheerio\"),mdx(\"p\",null,\"Before anything else, make sure you have a coverage report generated by your testing tool. In our case, we will use the HTML report generated by \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/bcoe/c8\"}),\"c8\"),\". This report will look something like this:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-html\",metastring:\"filename=./coverage/index.html\",filename:\"./coverage/index.html\"}),`<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <div class=\"wrapper\">\n      <div class=\"pad1\">\n        <div class=\"clearfix\">\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Statements</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Branches</span>\n            <span class=\"fraction\">74/74</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">90.9%</span>\n            <span class=\"quiet\">Functions</span>\n            <span class=\"fraction\">33/33</span>\n          </div>\n          <div class=\"fl pad1y space-right2\">\n            <span class=\"strong\">100%</span>\n            <span class=\"quiet\">Lines</span>\n            <span class=\"fraction\">786/786</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n`)),mdx(\"p\",null,\"We will use \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/cheeriojs/cheerio\"}),\"cheerio\"),\", a \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://jquery.com/\"}),\"jQuery\"),\"-like library for server-side to extract the percentage data from the HTML. Install it to your \",mdx(\"inlineCode\",{parentName:\"p\"},\"devDependencies\"),\" using the package manager of your choice:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-bash\"}),`# npm\nnpm install --save-dev cheerio\n\n# yarn\nyarn add --dev cheerio\n\n# pnpm\npnpm add --save-dev cheerio\n`)),mdx(\"h2\",e({},{id:\"step-2-create-a-script-to-extract-coverage-data\"}),\"Step 2: Create a Script to Extract Coverage Data\"),mdx(\"p\",null,\"Next, we need to create the actual script that will extract the coverage data from the HTML report. Create a new file called \",mdx(\"inlineCode\",{parentName:\"p\"},\"./scripts/generate-badges.js\"),\" and add the following code:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-js\",metastring:\"filename=./scripts/generate-badges.js\",filename:\"./scripts/generate-badges.js\"}),`const fs = require('fs');\nconst https = require('https');\nconst cheerio = require('cheerio');\n\nconst coverageFile = './coverage/index.html';\nconst badgesDir = './coverage/badges';\n\n// Read the coverage HTML file.\nfs.readFile(coverageFile, 'utf-8', (err, data) => {\n  if (err) {\n    console.error(\\`Error reading coverage file: \\${err}\\`);\n    process.exit(1);\n  }\n\n  // Parse the HTML using Cheerio.\n  const $ = cheerio.load(data);\n\n  // Construct the shields.io URL for each badge.\n  const statementsBadgeUrl = generateUrl('statements', extractPercentage($, 1));\n  const branchesBadgeUrl = generateUrl('branches', extractPercentage($, 2));\n  const functionsBadgeUrl = generateUrl('functions', extractPercentage($, 3));\n  const linesBadgeUrl = generateUrl('lines', extractPercentage($, 4));\n\n  // Create the badges directory if it does not exist.\n  if (!fs.existsSync(badgesDir)) {\n    fs.mkdirSync(badgesDir);\n  }\n\n  // Download each badge and save it to the badges directory.\n  downloadBadge(statementsBadgeUrl, \\`\\${badgesDir}/statements.svg\\`);\n  downloadBadge(branchesBadgeUrl, \\`\\${badgesDir}/branches.svg\\`);\n  downloadBadge(functionsBadgeUrl, \\`\\${badgesDir}/functions.svg\\`);\n  downloadBadge(linesBadgeUrl, \\`\\${badgesDir}/lines.svg\\`);\n\n  console.log('Code coverage badges created successfully.');\n});\n\n/**\n * Generate a shields.io URL for a badge.\n *\n * Change the color of the badge based on the percentage.\n *\n * @param {string} text The text to display on the badge.\n * @param {number} percentage The percentage to display on the badge.\n * @returns {string} The shields.io URL.\n */\nconst generateUrl = (text, percentage) => {\n  let color = 'brightgreen';\n  if (percentage < 70) {\n    color = 'red';\n  } else if (percentage < 80) {\n    color = 'yellow';\n  } else if (percentage < 90) {\n    color = 'orange';\n  }\n  return \\`https://img.shields.io/badge/coverage%3A\\${text}-\\${percentage}%25-\\${color}.svg\\`;\n};\n\n/**\n * Extract the code coverage percentage from the HTML.\n * @param {Cheerio} $ The Cheerio object.\n * @param {number} index The index of the element to extract.\n */\nconst extractPercentage = ($, index) => {\n  const text = $(\\`.pad1y:nth-child(\\${index}) span.strong\\`) ?? '0';\n  const percentage = text.text().trim().replace('%', '');\n  return parseFloat(percentage);\n};\n\n/**\n * Download a badge from shields.io.\n * @param {string} url The shields.io URL.\n * @param {string} filename The filename to save the badge to.\n */\nconst downloadBadge = (url, filename) => {\n  https.get(url, (res) => {\n    if (res.statusCode !== 200) {\n      console.error(\\`Error downloading badge: \\${res.statusMessage}\\`);\n      return;\n    }\n\n    const file = fs.createWriteStream(filename);\n    res.pipe(file);\n    file.on('finish', () => {\n      file.close();\n    });\n  });\n};\n`)),mdx(\"p\",null,\"This is a fairly straightforward script that uses Cheerio to parse the HTML report and extract the coverage data. It then uses the data to generate the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://shields.io/\"}),\"shields.io\"),\" URLs for each badge type. Finally, it downloads each badge and saves it to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"./coverage/badges\"),\" directory.\"),mdx(\"p\",null,\"Update your \",mdx(\"inlineCode\",{parentName:\"p\"},\"package.json\"),\" to add a new script that will run the \",mdx(\"inlineCode\",{parentName:\"p\"},\"generate-badges.js\"),\" script:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-json\",metastring:\"filename=package.json\",filename:\"package.json\"}),`{\n  \"scripts\": {\n    // ...\n    \"generate-badges\": \"node ./scripts/generate-badges.js\"\n  }\n}\n`)),mdx(\"p\",null,\"Run the script to generate the badges:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-bash\"}),`# generate the coverage report first\npnpm coverage\n\n# generate the badges\npnpm generate-badges\n`)),mdx(\"h2\",e({},{id:\"step-3-configure-github-actions\"}),\"Step 3: Configure GitHub Actions\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": For this guide, we will use \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://pnpm.io/\"}),\"pnpm\"),\", but the commands should be similar for other package managers.\")),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": This requires that you have an SSH Deploy Key configured for your repository. See \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"Create SSH Deploy Key\"),\" for more information.\")),mdx(\"p\",null,\"In your repository, create a \",mdx(\"inlineCode\",{parentName:\"p\"},\".github/workflows\"),\" directory if it doesn't already exist. Then, create a new YAML file inside the workflows directory called \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage-badge.yml\"),\". This file will define the GitHub Actions workflow that generates the coverage badge.\"),mdx(\"p\",null,\"Add the following content to \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage-badge.yml\"),\":\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\",metastring:\"filename=.github/workflows/coverage-badge.yml\",filename:\".github/workflows/coverage-badge.yml\"}),`name: (main) coverage badge\n\non:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n\njobs:\n  coverage-badge:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: \\${{ matrix.os }}\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: setup node\n        uses: actions/setup-node@v3\n        with:\n          node-version: \\${{ matrix.node }}\n      - name: install pnpm\n        uses: pnpm/action-setup@v2\n        id: pnpm-install\n        with:\n          version: \\${{ matrix.pnpm }}\n          run_install: false\n      - name: get pnpm store directory\n        id: pnpm-cache\n        shell: bash\n        run: |\n          echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n      - name: Setup pnpm cache\n        uses: actions/cache@v3\n        with:\n          path: \\${{ steps.pnpm-cache.outputs.STORE_PATH }}\n          key: \\${{ runner.os }}-pnpm-store-\\${{ hashFiles('**/pnpm-lock.yaml') }}\n          restore-keys: |\n            \\${{ runner.os }}-pnpm-store-\n      - name: install dependencies\n        run: pnpm install\n      - name: run coverage\n        run: pnpm coverage\n      - name: generate badges\n        run: pnpm generate-badges\n      - name: push coverage artifacts to another branch\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: \\${{ secrets.COVERAGE_DEPLOY_KEY }}\n          publish_dir: ./coverage\n          publish_branch: coverage\n          allow_empty_commit: true\n`)),mdx(\"p\",null,\"Let's break down the workflow into its various sections:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`on:\n  workflow_dispatch:\n  push:\n    branches:\n      - main\n`)),mdx(\"p\",null,\"The workflow is triggered when there's a push to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"main\"),\" branch or can be triggered manually (\",mdx(\"a\",e({parentName:\"p\"},{href:\"https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch\"}),mdx(\"inlineCode\",{parentName:\"a\"},\"workflow_dispatch\")),\").\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`jobs:\n  covera:\n    strategy:\n      matrix:\n        os:\n          - ubuntu-latest\n        node:\n          - 18.14.2\n        pnpm:\n          - 7\n    runs-on: \\${{ matrix.os }}\n`)),mdx(\"p\",null,\"We're using a matrix strategy to run the workflow on multiple operating systems, Node.js versions, and pnpm versions. For our purpose, we will only use one version of each, but this is a good practice to follow.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: checkout repository\n  uses: actions/checkout@v3\n- name: setup node\n  uses: actions/setup-node@v3\n  with:\n    node-version: \\${{ matrix.node }}\n`)),mdx(\"p\",null,\"This step checks out your repository using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/checkout\"}),\"actions/checkout\"),\" action. Then, it sets up Node.js using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/setup-node\"}),\"actions/setup-node\"),\" action.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: install pnpm\n  uses: pnpm/action-setup@v2\n  id: pnpm-install\n  with:\n    version: \\${{ matrix.pnpm }}\n    run_install: false\n`)),mdx(\"p\",null,\"This step installs pnpm using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/pnpm/action-setup\"}),\"pnpm/action-setup\"),\" action and the specified pnpm version from the matrix. We're not installing any dependencies yet, so we don't need to run \",mdx(\"inlineCode\",{parentName:\"p\"},\"pnpm install\"),\".\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: get pnpm store directory\n  id: pnpm-cache\n  shell: bash\n  run: |\n    echo \"STORE_PATH=$(pnpm store path)\" >> $GITHUB_OUTPUT\n- name: Setup pnpm cache\n  uses: actions/cache@v3\n  with:\n    path: \\${{ steps.pnpm-cache.outputs.STORE_PATH }}\n    key: \\${{ runner.os }}-pnpm-store-\\${{ hashFiles('**/pnpm-lock.yaml') }}\n    restore-keys: |\n      \\${{ runner.os }}-pnpm-store-\n- name: install dependencies\n  run: pnpm install\n`)),mdx(\"p\",null,\"These steps will use the cache from \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/actions/cache\"}),\"actions/cache\"),\" and install the project's dependencies using pnpm. We're using the cache to reduce installation time and to avoid downloading the same dependencies multiple times.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: run coverage\n  run: pnpm coverage\n- name: generate badges\n  run: pnpm generate-badges\n`)),mdx(\"p\",null,\"This step runs the \",mdx(\"inlineCode\",{parentName:\"p\"},\"coverage\"),\" script, which should generate a coverage report. Then, it runs the \",mdx(\"inlineCode\",{parentName:\"p\"},\"generate-badges\"),\" script, which should generate the coverage badges.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-yaml\"}),`- name: push coverage artifacts to another branch\n  uses: peaceiris/actions-gh-pages@v3\n  with:\n    deploy_key: \\${{ secrets.COVERAGE_DEPLOY_KEY }}\n    publish_dir: ./coverage\n    publish_branch: coverage\n    allow_empty_commit: true\n`)),mdx(\"p\",null,\"Lastly, this step pushes the coverage artifacts, including the generated badges and the coverage report, to a separate coverage branch in your repository using the \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/peaceiris/actions-gh-pages\"}),\"peaceiris/actions-gh-pages\"),\" action.\"),mdx(\"p\",null,\"Options:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"deploy_key\"),\" option is set to the \",mdx(\"inlineCode\",{parentName:\"li\"},\"COVERAGE_DEPLOY_KEY\"),\" secret, which is a Deploy Key stored in your repository settings. This deploy key should have write access to the repository. Follow the instructions from \",mdx(\"a\",e({parentName:\"li\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"Create SSH Deploy Key\"),\" to generate it and add it to your repository.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"publish_dir\"),\" is set to \",mdx(\"inlineCode\",{parentName:\"li\"},\"./coverage\"),\", which is the directory containing the coverage report and badges.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"allow_empty_commit\"),\" option is set to true to allow empty commits if there are no changes in the coverage artifacts.\"),mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"inlineCode\",{parentName:\"li\"},\"publish_branch\"),\" is the name of the branch you want to push the coverage artifacts to. It's currently set to \",mdx(\"inlineCode\",{parentName:\"li\"},\"coverage\"),\", but you can change it to whatever you want.\")),mdx(\"h2\",e({},{id:\"step-4-add-badge-to-readme\"}),\"Step 4: Add Badge to README\"),mdx(\"p\",null,\"To display the coverage badge in your README file, add the following line at the top of your \",mdx(\"inlineCode\",{parentName:\"p\"},\"README.md\"),\" file:\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-md\",metastring:\"filename=README.md\",filename:\"README.md\"}),`![Coverage: Statements](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/statements.svg)\n![Coverage: Branches](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/branches.svg)\n![Coverage: Functions](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/functions.svg)\n![Coverage: Lines](https://raw.githubusercontent.com/<USER_NAME>/<REPO_NAME>/<PUBLISH_BRANCH_NAME>/badges/lines.svg)\n`)),mdx(\"p\",null,\"These lines will render the badges as an image. It should point to the latest badges in your \",mdx(\"inlineCode\",{parentName:\"p\"},\"<PUBLISH_BRANCH_NAME>\"),\" branch.\"),mdx(\"h2\",e({},{id:\"conclusion\"}),\"Conclusion\"),mdx(\"p\",null,\"Congratulations! You have successfully created a dynamic coverage badge for your Node.js project. This badge will help you showcase your project's test coverage and encourage you to maintain a high level of code quality. Don't hesitate to customize this workflow to suit your needs and adapt it to different coverage tools and badge styles.\"),mdx(\"p\",null,\"Happy coding!\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}},{"title":"Deploying a Repository Inside a GitHub Organization to Vercel Using GitHub Actions","layout":"posts","slug":"deploying-a-repository-inside-a-github-organization-to-vercel-using-github-actions","draft":false,"frontMatter":{"title":"Deploying a Repository Inside a GitHub Organization to Vercel Using GitHub Actions","publishedDate":"2023-03-28T20:11:00Z","tags":["GitHub","GitHub Actions","Vercel"],"description":"","disableComments":false},"rawContent":"\n[Vercel](https://vercel.com/) is a popular cloud service platform designed for hosting [Next.js](https://nextjs.org/) applications. While it offers free hosting for personal repositories, it doesn't allow deploying from repositories inside a GitHub Organization unless you subscribe to a paid plan.\n\nIn this blog post, we'll create a GitHub Action that duplicates the content of a repository inside a GitHub Organization to a repository in your personal GitHub account, allowing you to leverage Vercel's free hosting services.\n\n> **NOTE**: This approach may not be suitable for all scenarios, and ensuring proper security measures when dealing with sensitive data is essential.\n\n## Prerequisites\n\n- A personal GitHub account\n- A repository within a GitHub Organization (source repository)\n- A separate repository in your personal account to host the copied files (destination repository)\n\n## Step 1: Generate SSH Keys\n\nYou'll need to generate an SSH Deploy Key to securely push your content from the organization's repository to the external repository. Although you can also use a Personal Access Token, an SSH deploy key is recommended as it minimizes the impact of potential security breaches.\n\n```bash\nssh-keygen -t ed25519 -C \"$(git config user.email)\" -N \"\" -f github-<desitination-repo-name>\n```\n\nReplace the `<desitination-repo-name>` with the name of your destination repository and run the command. Afterwards, you should now have both public and private key files:\n\n- `github-<desitination-repo-name>.pub` (public)\n- `github-<desitination-repo-name>` (private)\n\n## Step 2: Add the private key to the Source Repository\n\n1. Visit the source repository's GitHub page.\n2. Click on \"Settings\" in the repository (not account settings).\n3. In the left-hand pane, click \"Secrets\", then \"Actions\".\n4. Click on \"New repository secret\".\n5. Name it `SSH_DEPLOY_KEY` and paste the contents of the private key file.\n6. Click \"Save\".\n\n## Step 3: Add the public key to the Destination Repository\n\n1. Visit the destination repository's GitHub page.\n2. Click on \"Settings\" in the repository (not account settings).\n3. In the left-hand side pane, click on \"Deploy keys.\"\n4. Click on \"Add deploy key\".\n5. Paste the contents of the public key file.\n6. Enable \"Allow write access\".\n7. Click \"Save\".\n\n## Step 4: Disable GitHub Actions on the Destination Repository\n\n1. Visit the destination repository's GitHub page.\n2. Click on \"Settings\" in the repository (not account settings).\n3. Click on \"Actions\" and then \"General\".\n4. Select \"Disable actions\".\n5. Click \"Save\".\n\n## Step 5: Create a GitHub Action Workflow\n\nCreate a new GitHub Action workflow in your source repository by adding a YAML file in the `.github/workflows` directory. Name the file `push-to-external-repo.yml` and paste the following content:\n\n```yaml filename=.github/workflows/push-to-external-repo.yml\nname: (main) push to external repo\non:\n  push:\n    branches:\n      - main\njobs:\n  push-to-external-repo:\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: push to external repository\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.SSH_DEPLOY_KEY }}\n          publish_dir: .\n          external_repository: <your-username>/<destination-repo-name>\n          publish_branch: main\n          allow_empty_commit: true\n```\n\nReplace `<your-username>` with your GitHub username and `<destination-repo-name>` with the name of the external repository in your personal account.\nThis action will copy everything from your organization's repository to your personal repository, including your GitHub Action workflows, so follow [Step 4](#step-4-disable-github-actions-on-the-destination-repository) to disable GitHub Actions on the destination repository.\n\n## Step 6: Run your workflow\n\nPush something to your `main` branch and see it be pushed to your `<your-username>/<destination-repo-name>` repository.\n\n## Step 7: Set up a project on Vercel\n\n1. On Vercel's \"New Project\" page, choose the account linked to the project under the \"Import Git Repository\" section.\n2. Find your personal repository in the list and select \"Import\".\n3. Vercel will automatically detect the framework and any necessary build settings. You can configure project settings, including build and development settings and environment variables, at this stage or later.\n4. Click the \"Deploy\" button. Vercel will create the project and deploy it based on the chosen configurations.\n","excerpt":"\n[Vercel](https://vercel.com/) is a popular cloud service platform designed for hosting [Next.js](https://nextjs.org/) applications. While it offers free hosting for personal repositories, it doesn't allow deploying from repositories inside a GitHub Organization unless you subscribe to a paid plan.\n...","serializedContent":{"compiledSource":"var c=Object.defineProperty,h=Object.defineProperties;var d=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable;var s=(e,t,i)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,o=(e,t)=>{for(var i in t||(t={}))r.call(t,i)&&s(e,i,t[i]);if(a)for(var i of a(t))l.call(t,i)&&s(e,i,t[i]);return e},p=(e,t)=>h(e,d(t));var u=(e,t)=>{var i={};for(var n in e)r.call(e,n)&&t.indexOf(n)<0&&(i[n]=e[n]);if(e!=null&&a)for(var n of a(e))t.indexOf(n)<0&&l.call(e,n)&&(i[n]=e[n]);return i};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var n=i,{components:e}=n,t=u(n,[\"components\"]);return mdx(MDXLayout,p(o(o({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"a\",o({parentName:\"p\"},{href:\"https://vercel.com/\"}),\"Vercel\"),\" is a popular cloud service platform designed for hosting \",mdx(\"a\",o({parentName:\"p\"},{href:\"https://nextjs.org/\"}),\"Next.js\"),\" applications. While it offers free hosting for personal repositories, it doesn't allow deploying from repositories inside a GitHub Organization unless you subscribe to a paid plan.\"),mdx(\"p\",null,\"In this blog post, we'll create a GitHub Action that duplicates the content of a repository inside a GitHub Organization to a repository in your personal GitHub account, allowing you to leverage Vercel's free hosting services.\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},mdx(\"strong\",{parentName:\"p\"},\"NOTE\"),\": This approach may not be suitable for all scenarios, and ensuring proper security measures when dealing with sensitive data is essential.\")),mdx(\"h2\",o({},{id:\"prerequisites\"}),\"Prerequisites\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"A personal GitHub account\"),mdx(\"li\",{parentName:\"ul\"},\"A repository within a GitHub Organization (source repository)\"),mdx(\"li\",{parentName:\"ul\"},\"A separate repository in your personal account to host the copied files (destination repository)\")),mdx(\"h2\",o({},{id:\"step-1-generate-ssh-keys\"}),\"Step 1: Generate SSH Keys\"),mdx(\"p\",null,\"You'll need to generate an SSH Deploy Key to securely push your content from the organization's repository to the external repository. Although you can also use a Personal Access Token, an SSH deploy key is recommended as it minimizes the impact of potential security breaches.\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-bash\"}),`ssh-keygen -t ed25519 -C \"$(git config user.email)\" -N \"\" -f github-<desitination-repo-name>\n`)),mdx(\"p\",null,\"Replace the \",mdx(\"inlineCode\",{parentName:\"p\"},\"<desitination-repo-name>\"),\" with the name of your destination repository and run the command. Afterwards, you should now have both public and private key files:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"github-<desitination-repo-name>.pub\"),\" (public)\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"github-<desitination-repo-name>\"),\" (private)\")),mdx(\"h2\",o({},{id:\"step-2-add-the-private-key-to-the-source-repository\"}),\"Step 2: Add the private key to the Source Repository\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Visit the source repository's GitHub page.\"),mdx(\"li\",{parentName:\"ol\"},'Click on \"Settings\" in the repository (not account settings).'),mdx(\"li\",{parentName:\"ol\"},'In the left-hand pane, click \"Secrets\", then \"Actions\".'),mdx(\"li\",{parentName:\"ol\"},'Click on \"New repository secret\".'),mdx(\"li\",{parentName:\"ol\"},\"Name it \",mdx(\"inlineCode\",{parentName:\"li\"},\"SSH_DEPLOY_KEY\"),\" and paste the contents of the private key file.\"),mdx(\"li\",{parentName:\"ol\"},'Click \"Save\".')),mdx(\"h2\",o({},{id:\"step-3-add-the-public-key-to-the-destination-repository\"}),\"Step 3: Add the public key to the Destination Repository\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Visit the destination repository's GitHub page.\"),mdx(\"li\",{parentName:\"ol\"},'Click on \"Settings\" in the repository (not account settings).'),mdx(\"li\",{parentName:\"ol\"},'In the left-hand side pane, click on \"Deploy keys.\"'),mdx(\"li\",{parentName:\"ol\"},'Click on \"Add deploy key\".'),mdx(\"li\",{parentName:\"ol\"},\"Paste the contents of the public key file.\"),mdx(\"li\",{parentName:\"ol\"},'Enable \"Allow write access\".'),mdx(\"li\",{parentName:\"ol\"},'Click \"Save\".')),mdx(\"h2\",o({},{id:\"step-4-disable-github-actions-on-the-destination-repository\"}),\"Step 4: Disable GitHub Actions on the Destination Repository\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Visit the destination repository's GitHub page.\"),mdx(\"li\",{parentName:\"ol\"},'Click on \"Settings\" in the repository (not account settings).'),mdx(\"li\",{parentName:\"ol\"},'Click on \"Actions\" and then \"General\".'),mdx(\"li\",{parentName:\"ol\"},'Select \"Disable actions\".'),mdx(\"li\",{parentName:\"ol\"},'Click \"Save\".')),mdx(\"h2\",o({},{id:\"step-5-create-a-github-action-workflow\"}),\"Step 5: Create a GitHub Action Workflow\"),mdx(\"p\",null,\"Create a new GitHub Action workflow in your source repository by adding a YAML file in the \",mdx(\"inlineCode\",{parentName:\"p\"},\".github/workflows\"),\" directory. Name the file \",mdx(\"inlineCode\",{parentName:\"p\"},\"push-to-external-repo.yml\"),\" and paste the following content:\"),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-yaml\",metastring:\"filename=.github/workflows/push-to-external-repo.yml\",filename:\".github/workflows/push-to-external-repo.yml\"}),`name: (main) push to external repo\non:\n  push:\n    branches:\n      - main\njobs:\n  push-to-external-repo:\n    runs-on: ubuntu-latest\n    steps:\n      - name: checkout repository\n        uses: actions/checkout@v3\n      - name: push to external repository\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: \\${{ secrets.SSH_DEPLOY_KEY }}\n          publish_dir: .\n          external_repository: <your-username>/<destination-repo-name>\n          publish_branch: main\n          allow_empty_commit: true\n`)),mdx(\"p\",null,\"Replace \",mdx(\"inlineCode\",{parentName:\"p\"},\"<your-username>\"),\" with your GitHub username and \",mdx(\"inlineCode\",{parentName:\"p\"},\"<destination-repo-name>\"),` with the name of the external repository in your personal account.\nThis action will copy everything from your organization's repository to your personal repository, including your GitHub Action workflows, so follow `,mdx(\"a\",o({parentName:\"p\"},{href:\"#step-4-disable-github-actions-on-the-destination-repository\"}),\"Step 4\"),\" to disable GitHub Actions on the destination repository.\"),mdx(\"h2\",o({},{id:\"step-6-run-your-workflow\"}),\"Step 6: Run your workflow\"),mdx(\"p\",null,\"Push something to your \",mdx(\"inlineCode\",{parentName:\"p\"},\"main\"),\" branch and see it be pushed to your \",mdx(\"inlineCode\",{parentName:\"p\"},\"<your-username>/<destination-repo-name>\"),\" repository.\"),mdx(\"h2\",o({},{id:\"step-7-set-up-a-project-on-vercel\"}),\"Step 7: Set up a project on Vercel\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},`On Vercel's \"New Project\" page, choose the account linked to the project under the \"Import Git Repository\" section.`),mdx(\"li\",{parentName:\"ol\"},'Find your personal repository in the list and select \"Import\".'),mdx(\"li\",{parentName:\"ol\"},\"Vercel will automatically detect the framework and any necessary build settings. You can configure project settings, including build and development settings and environment variables, at this stage or later.\"),mdx(\"li\",{parentName:\"ol\"},'Click the \"Deploy\" button. Vercel will create the project and deploy it based on the chosen configurations.')))}MDXContent.isMDXComponent=!0;\n","scope":{}}},{"title":"Deploy Hugo Site Using GitHub Actions","layout":"posts","slug":"deploy-hugo-site-using-github-actions","draft":false,"frontMatter":{"title":"Deploy Hugo Site Using GitHub Actions","publishedDate":"2020-06-28T03:02:37+08:00","tags":["Hugo","GitHub Actions"],"description":"","disableComments":false},"rawContent":"\nAfter creating a new project using\n[Hugo's Quick Start guide](https://gohugo.io/getting-started/quick-start/), you\ncan then deploy to [GitHub Pages](https://pages.github.com/).\n\n### Git Branches\n\nFor this site, we are deploying the project hosted at\n[napjoseph/napjoseph.github.io](https://github.com/napjoseph/napjoseph.github.io/).\n\nSince this is an\n[Organization Pages-type repository](https://docs.github.com/en/github/working-with-github-pages/about-github-pages#types-of-github-pages-sites),\nwe will be using following branches for our workflow:\n\n```bash\n$ git branch\nmaster           # the branch that GitHub pages will serve the files from\nstable           # the main development branch where all pull requests will be merged to\nid_your_feature  # additional development branches for new features\n```\n\n### Add your Deploy Key\n\nFollow the tutorial over at\n[peaceiris/actions-gh-pages](https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key)\nand add an SSH deploy key for your project.\n\n### Create your GitHub Action\n\nAfterwards, create a directory for your workflows and add the config file for\nyour new action.\n\n```bash\n$ mkdir -p .github/workflows\n$ touch .github/workflows/deploy.yml\n```\n\n```yaml filename=.github/workflows/deploy.yml\nname: deploy-to-master\n\non:\n  push:\n    branches:\n      - stable\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n        with:\n          persist-credentials: false\n\n      - name: Update theme\n        run: git submodule update --init --recursive\n\n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: '0.74.3'\n\n      - name: Build\n        run: HUGO_ENV=production hugo --minify\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./public\n          publish_branch: master\n          keep_files: false\n          allow_empty_commit: true\n```\n\n### Deployment\n\nAfter merging your pull requests to the `stable` branch, it should automatically\ndeploy to the `master` branch.\n","excerpt":"\nAfter creating a new project using\n[Hugo's Quick Start guide](https://gohugo.io/getting-started/quick-start/), you\ncan then deploy to [GitHub Pages](https://pages.github.com/).\n\n### Git Branches\n\nFor this site, we are deploying the project hosted at\n[napjoseph/napjoseph.github.io](https://github.co...","serializedContent":{"compiledSource":"var l=Object.defineProperty,c=Object.defineProperties;var d=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable;var n=(e,t,a)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,o=(e,t)=>{for(var a in t||(t={}))s.call(t,a)&&n(e,a,t[a]);if(i)for(var a of i(t))p.call(t,a)&&n(e,a,t[a]);return e},u=(e,t)=>c(e,d(t));var h=(e,t)=>{var a={};for(var r in e)s.call(e,r)&&t.indexOf(r)<0&&(a[r]=e[r]);if(e!=null&&i)for(var r of i(e))t.indexOf(r)<0&&p.call(e,r)&&(a[r]=e[r]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var r=a,{components:e}=r,t=h(r,[\"components\"]);return mdx(MDXLayout,u(o(o({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`After creating a new project using\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"https://gohugo.io/getting-started/quick-start/\"}),\"Hugo's Quick Start guide\"),`, you\ncan then deploy to `,mdx(\"a\",o({parentName:\"p\"},{href:\"https://pages.github.com/\"}),\"GitHub Pages\"),\".\"),mdx(\"h3\",o({},{id:\"git-branches\"}),\"Git Branches\"),mdx(\"p\",null,`For this site, we are deploying the project hosted at\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"https://github.com/napjoseph/napjoseph.github.io/\"}),\"napjoseph/napjoseph.github.io\"),\".\"),mdx(\"p\",null,`Since this is an\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"https://docs.github.com/en/github/working-with-github-pages/about-github-pages#types-of-github-pages-sites\"}),\"Organization Pages-type repository\"),`,\nwe will be using following branches for our workflow:`),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-bash\"}),`$ git branch\nmaster           # the branch that GitHub pages will serve the files from\nstable           # the main development branch where all pull requests will be merged to\nid_your_feature  # additional development branches for new features\n`)),mdx(\"h3\",o({},{id:\"add-your-deploy-key\"}),\"Add your Deploy Key\"),mdx(\"p\",null,`Follow the tutorial over at\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-create-ssh-deploy-key\"}),\"peaceiris/actions-gh-pages\"),`\nand add an SSH deploy key for your project.`),mdx(\"h3\",o({},{id:\"create-your-github-action\"}),\"Create your GitHub Action\"),mdx(\"p\",null,`Afterwards, create a directory for your workflows and add the config file for\nyour new action.`),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-bash\"}),`$ mkdir -p .github/workflows\n$ touch .github/workflows/deploy.yml\n`)),mdx(\"pre\",null,mdx(\"code\",o({parentName:\"pre\"},{className:\"language-yaml\",metastring:\"filename=.github/workflows/deploy.yml\",filename:\".github/workflows/deploy.yml\"}),`name: deploy-to-master\n\non:\n  push:\n    branches:\n      - stable\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2\n        with:\n          persist-credentials: false\n\n      - name: Update theme\n        run: git submodule update --init --recursive\n\n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: '0.74.3'\n\n      - name: Build\n        run: HUGO_ENV=production hugo --minify\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          deploy_key: \\${{ secrets.ACTIONS_DEPLOY_KEY }}\n          publish_dir: ./public\n          publish_branch: master\n          keep_files: false\n          allow_empty_commit: true\n`)),mdx(\"h3\",o({},{id:\"deployment\"}),\"Deployment\"),mdx(\"p\",null,\"After merging your pull requests to the \",mdx(\"inlineCode\",{parentName:\"p\"},\"stable\"),` branch, it should automatically\ndeploy to the `,mdx(\"inlineCode\",{parentName:\"p\"},\"master\"),\" branch.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}}]},"__N_SSG":true}